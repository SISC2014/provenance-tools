<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cctools: buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_e91b50daf043faf49e177c41e4045673.html">dttools</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_6799dea93b790a5bddb17668b32e0132.html">src</a>
  </div>
</div>
<div class="contents">
<h1>buffer.h File Reference</h1>
<p>String Buffer Operations.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>

<p><a href="buffer_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuffer.html">buffer</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0551fc46a6f4804315c348a189ff308c">buffer_putstring</a>(b, s)&nbsp;&nbsp;&nbsp;(buffer_putlstring(b,s,strlen(s)))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the string to the end of the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a0551fc46a6f4804315c348a189ff308c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3e9c64ecbc4f1d887662569a1e50828a">buffer_putliteral</a>(b, l)&nbsp;&nbsp;&nbsp;(buffer_putlstring(b,l &quot;&quot;,sizeof(l)-1))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the string literal to the end of the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a3e9c64ecbc4f1d887662569a1e50828a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8b549043c62502e9808e2a4f6238984b">buffer_init</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a8b549043c62502e9808e2a4f6238984b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a7733d690cdc50231d347cca57b07eb68">buffer_ubuf</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, char *buf, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use the provided <a class="el" href="structbuffer.html">buffer</a> as a starting <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a7733d690cdc50231d347cca57b07eb68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a6e67806fd1c7fb6fcacf879a845b39be">buffer_max</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, size_t max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum size of the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a6e67806fd1c7fb6fcacf879a845b39be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0006f462fd2611883da0401d70c049e5">buffer_abortonfailure</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, int abortonfailure)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="structbuffer.html">buffer</a> to call fatal(.  <a href="#a0006f462fd2611883da0401d70c049e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af075a6de5c39e3a750ba0f710c139a7f">buffer_free</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free any resources and memory in use by a <a class="el" href="structbuffer.html">buffer</a>.  <a href="#af075a6de5c39e3a750ba0f710c139a7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ade08d59a590f5e17508c0bce02f2b795">buffer_putvfstring</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, const char *format, va_list ap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the formatted output to the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#ade08d59a590f5e17508c0bce02f2b795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4fa50b2bf136939548d62a09e6cf7401">buffer_putfstring</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, const char *format,...) __attribute__((format(printf</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the formatted output to the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a4fa50b2bf136939548d62a09e6cf7401"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a60aac4cd6e4bf803ff7a2bb839167ea2">buffer_putlstring</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, const char *str, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the string to the end of the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a60aac4cd6e4bf803ff7a2bb839167ea2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ac00ed4e5591ab5f6a96b83233432e004">buffer_tostring</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, size_t *size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="structbuffer.html">buffer</a> as a string.  <a href="#ac00ed4e5591ab5f6a96b83233432e004"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a29ceca8be88b8e553ad6d0aefdaa95fe">buffer_rewind</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b, size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rewinds the <a class="el" href="structbuffer.html">buffer</a> to position n.  <a href="#a29ceca8be88b8e553ad6d0aefdaa95fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a3943a78dd3fc06a79e06f7aaa30bf4b0">buffer_pos</a> (<a class="el" href="structbuffer.html">buffer_t</a> *b)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current position in the <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a3943a78dd3fc06a79e06f7aaa30bf4b0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>String Buffer Operations. </p>
<p>You can use the <a class="el" href="structbuffer.html">buffer</a> in the same way you would print to a file. Use the <a class="el" href="structbuffer.html">buffer</a> to do formatted printing. When you are done retrieve the final string using buffer_tostring. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a0551fc46a6f4804315c348a189ff308c"></a><!-- doxytag: member="buffer.h::buffer_putstring" ref="a0551fc46a6f4804315c348a189ff308c" args="(b, s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buffer_putstring</td>
          <td>(</td>
          <td class="paramtype">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(buffer_putlstring(b,s,strlen(s)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the string to the end of the <a class="el" href="structbuffer.html">buffer</a>. </p>
<p>Length derived via strlen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e9c64ecbc4f1d887662569a1e50828a"></a><!-- doxytag: member="buffer.h::buffer_putliteral" ref="a3e9c64ecbc4f1d887662569a1e50828a" args="(b, l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buffer_putliteral</td>
          <td>(</td>
          <td class="paramtype">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">l&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(buffer_putlstring(b,l &quot;&quot;,sizeof(l)-1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the string literal to the end of the <a class="el" href="structbuffer.html">buffer</a>. </p>
<p>Length derived via sizeof. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>The literal string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on error. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8b549043c62502e9808e2a4f6238984b"></a><!-- doxytag: member="buffer.h::buffer_init" ref="a8b549043c62502e9808e2a4f6238984b" args="(buffer_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a <a class="el" href="structbuffer.html">buffer</a>. </p>
<p>The <a class="el" href="structbuffer.html">buffer</a> includes a reasonably sized starting <a class="el" href="structbuffer.html">buffer</a> as part of its definition. Usually this means for small strings being built, nothing is ever allocated on the heap. You can specify a larger starting <a class="el" href="structbuffer.html">buffer</a> if this is inadequate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7733d690cdc50231d347cca57b07eb68"></a><!-- doxytag: member="buffer.h::buffer_ubuf" ref="a7733d690cdc50231d347cca57b07eb68" args="(buffer_t *b, char *buf, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_ubuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the provided <a class="el" href="structbuffer.html">buffer</a> as a starting <a class="el" href="structbuffer.html">buffer</a>. </p>
<p>This function should only be called before any work is done on the <a class="el" href="structbuffer.html">buffer</a>. The user <a class="el" href="structbuffer.html">buffer</a> is only used if it is larger than the internal starting <a class="el" href="structbuffer.html">buffer</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A starting <a class="el" href="structbuffer.html">buffer</a> to initially use to avoid allocating memory on the heap. (can be NULL) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the <a class="el" href="structbuffer.html">buffer</a>. (ignored if buf == NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e67806fd1c7fb6fcacf879a845b39be"></a><!-- doxytag: member="buffer.h::buffer_max" ref="a6e67806fd1c7fb6fcacf879a845b39be" args="(buffer_t *b, size_t max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum size of the <a class="el" href="structbuffer.html">buffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>The maximum amount of memory to allocate. (0 is unlimited) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0006f462fd2611883da0401d70c049e5"></a><!-- doxytag: member="buffer.h::buffer_abortonfailure" ref="a0006f462fd2611883da0401d70c049e5" args="(buffer_t *b, int abortonfailure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_abortonfailure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>abortonfailure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the <a class="el" href="structbuffer.html">buffer</a> to call fatal(. </p>
<p>..) on error instead of returning an error code.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abortonfailure</em>&nbsp;</td><td>Kill the process on errors. (you no longer have to check returns) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af075a6de5c39e3a750ba0f710c139a7f"></a><!-- doxytag: member="buffer.h::buffer_free" ref="af075a6de5c39e3a750ba0f710c139a7f" args="(buffer_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free any resources and memory in use by a <a class="el" href="structbuffer.html">buffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade08d59a590f5e17508c0bce02f2b795"></a><!-- doxytag: member="buffer.h::buffer_putvfstring" ref="ade08d59a590f5e17508c0bce02f2b795" args="(buffer_t *b, const char *format, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buffer_putvfstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the formatted output to the <a class="el" href="structbuffer.html">buffer</a>. </p>
<p>The format string follows the same semantics as the UNIX vprintf function. buffer_putvfstring does not call the variable argument macros va_(start|end) on ap. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ap</em>&nbsp;</td><td>The variable argument <a class="el" href="structlist.html">list</a> for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fa50b2bf136939548d62a09e6cf7401"></a><!-- doxytag: member="buffer.h::buffer_putfstring" ref="a4fa50b2bf136939548d62a09e6cf7401" args="(buffer_t *b, const char *format,...) __attribute__((format(printf" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buffer_putfstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the formatted output to the <a class="el" href="structbuffer.html">buffer</a>. </p>
<p>The format string follows the same semantics as the UNIX vprintf function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The format string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>The variable arguments for the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a60aac4cd6e4bf803ff7a2bb839167ea2"></a><!-- doxytag: member="buffer.h::buffer_putlstring" ref="a60aac4cd6e4bf803ff7a2bb839167ea2" args="(buffer_t *b, const char *str, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int buffer_putlstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the string to the end of the <a class="el" href="structbuffer.html">buffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a> to fill. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to append. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac00ed4e5591ab5f6a96b83233432e004"></a><!-- doxytag: member="buffer.h::buffer_tostring" ref="ac00ed4e5591ab5f6a96b83233432e004" args="(buffer_t *b, size_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* buffer_tostring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the <a class="el" href="structbuffer.html">buffer</a> as a string. </p>
<p>The string is no longer valid after deleting the <a class="el" href="structbuffer.html">buffer</a>. A final ASCII NUL character is guaranteed to terminate the string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the string is placed in this variable. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="structbuffer.html">buffer</a> as a string with a NUL terminator. </dd></dl>

</div>
</div>
<a class="anchor" id="a29ceca8be88b8e553ad6d0aefdaa95fe"></a><!-- doxytag: member="buffer.h::buffer_rewind" ref="a29ceca8be88b8e553ad6d0aefdaa95fe" args="(buffer_t *b, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buffer_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rewinds the <a class="el" href="structbuffer.html">buffer</a> to position n. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The position to rewind to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3943a78dd3fc06a79e06f7aaa30bf4b0"></a><!-- doxytag: member="buffer.h::buffer_pos" ref="a3943a78dd3fc06a79e06f7aaa30bf4b0" args="(buffer_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t buffer_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuffer.html">buffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current position in the <a class="el" href="structbuffer.html">buffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="structbuffer.html">buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current position. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 10 Jul 2014 for cctools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
