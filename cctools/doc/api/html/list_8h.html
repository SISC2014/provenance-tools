<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cctools: list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_e91b50daf043faf49e177c41e4045673.html">dttools</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_6799dea93b790a5bddb17668b32e0132.html">src</a>
  </div>
</div>
<div class="contents">
<h1>list.h File Reference</h1>
<p>Double-linked non-intrusive <a class="el" href="structlist.html">list</a>.  
<a href="#_details">More...</a></p>

<p><a href="list_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlist__node.html">list_node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlist.html">list</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#aa9b519436bb70021ad4de5cd65fa56d0">list_create</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new linked <a class="el" href="structlist.html">list</a>.  <a href="#aa9b519436bb70021ad4de5cd65fa56d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a222df3db3c9d5b24d1a4d4d9e8d5bd1b">list_duplicate</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a linked <a class="el" href="structlist.html">list</a> Returns a copy of the linked <a class="el" href="structlist.html">list</a>.  <a href="#a222df3db3c9d5b24d1a4d4d9e8d5bd1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ab5fdf1a904264be077ce19a432b1b119">list_delete</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a linked <a class="el" href="structlist.html">list</a>.  <a href="#ab5fdf1a904264be077ce19a432b1b119"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a82587229be89a53219c37bc68ee973f6">list_free</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free every item referred to by the <a class="el" href="structlist.html">list</a>.  <a href="#a82587229be89a53219c37bc68ee973f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ad1636df82df6c1fd784f6ca3afd32d1f">list_splice</a> (struct <a class="el" href="structlist.html">list</a> *top, struct <a class="el" href="structlist.html">list</a> *bottom)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splice two lists together.  <a href="#ad1636df82df6c1fd784f6ca3afd32d1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a2b3b19c22b3b693bc16efafda2d57d88">list_split</a> (struct <a class="el" href="structlist.html">list</a> *src, list_op_t cmp, const void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a <a class="el" href="structlist.html">list</a> into two at the given item If arg is NULL or not found, list_split returns NULL and the <a class="el" href="structlist.html">list</a> is unaffected.  <a href="#a2b3b19c22b3b693bc16efafda2d57d88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ac1ab4538dda5826f75c4b31e3bc12d6c">list_size</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the elements in a <a class="el" href="structlist.html">list</a>.  <a href="#ac1ab4538dda5826f75c4b31e3bc12d6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a9179a4dcfa933c42fba5290f5e4f5614">list_push_priority</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, void *item, int prio)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push an item in priority order.  <a href="#a9179a4dcfa933c42fba5290f5e4f5614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ab9fa977fbbaed21f9d745c7810145d3d">list_push_head</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, void *item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push an item onto the <a class="el" href="structlist.html">list</a> head.  <a href="#ab9fa977fbbaed21f9d745c7810145d3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a66aea0e0d2a269e7802b0fcdc4e29527">list_pop_head</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop an item off of the <a class="el" href="structlist.html">list</a> head.  <a href="#a66aea0e0d2a269e7802b0fcdc4e29527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a10268615c649d4f981662a6feed9c9ad">list_peek_head</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the <a class="el" href="structlist.html">list</a> head.  <a href="#a10268615c649d4f981662a6feed9c9ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ad01ebcdcfec40d1949d41a6a7bce27ad">list_push_tail</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, void *item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push an item onto the <a class="el" href="structlist.html">list</a> tail.  <a href="#ad01ebcdcfec40d1949d41a6a7bce27ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a3bf0ceb2176fa239e2cb36a15d444849">list_pop_tail</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pop an item off of the <a class="el" href="structlist.html">list</a> tail.  <a href="#a3bf0ceb2176fa239e2cb36a15d444849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#aef4649894f08ae98b870124c4098160b">list_peek_tail</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the <a class="el" href="structlist.html">list</a> tail.  <a href="#aef4649894f08ae98b870124c4098160b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a3e2d70ea2fa24cbf13bad4676427214b">list_peek_current</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the current element in the iteration.  <a href="#a3e2d70ea2fa24cbf13bad4676427214b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ac19d222298487ce12b445def0b1cf55e">list_find</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, list_op_t cmp, const void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find an element within a <a class="el" href="structlist.html">list</a> This function searches the <a class="el" href="structlist.html">list</a>, comparing each element in the <a class="el" href="structlist.html">list</a> to arg, and returns a pointer to the first matching element.  <a href="#ac19d222298487ce12b445def0b1cf55e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a7a04edf349230926222efa9c209b85d4">list_remove</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, const void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an item from the <a class="el" href="structlist.html">list</a> This function searches the <a class="el" href="structlist.html">list</a> for the item pointed to by value and removes it.  <a href="#a7a04edf349230926222efa9c209b85d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a85f7c1280b012f5ce53f245894835c67">list_first_item</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin traversing a <a class="el" href="structlist.html">list</a>.  <a href="#a85f7c1280b012f5ce53f245894835c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a508716109f6c47dd73b3b07b411425f6">list_next_item</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue traversing a <a class="el" href="structlist.html">list</a>.  <a href="#a508716109f6c47dd73b3b07b411425f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a04051f7b784370d26615dcab371cca8e">list_iterate</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, list_op_t op, const void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a function to a <a class="el" href="structlist.html">list</a>.  <a href="#a04051f7b784370d26615dcab371cca8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a9ca1a102b90872fe07b043f07a7c6f7c">list_iterate_reverse</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, list_op_t op, const void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a function to a <a class="el" href="structlist.html">list</a> in reverse.  <a href="#a9ca1a102b90872fe07b043f07a7c6f7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a9a181680b0cc667bd5e812f33802284c">list_sort</a> (struct <a class="el" href="structlist.html">list</a> *<a class="el" href="structlist.html">list</a>, int(*comparator)(const void *, const void *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort a <a class="el" href="structlist.html">list</a> using a comparator function.  <a href="#a9a181680b0cc667bd5e812f33802284c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Double-linked non-intrusive <a class="el" href="structlist.html">list</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa9b519436bb70021ad4de5cd65fa56d0"></a><!-- doxytag: member="list.h::list_create" ref="aa9b519436bb70021ad4de5cd65fa56d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist.html">list</a>* list_create </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new linked <a class="el" href="structlist.html">list</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to an empty linked <a class="el" href="structlist.html">list</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a222df3db3c9d5b24d1a4d4d9e8d5bd1b"></a><!-- doxytag: member="list.h::list_duplicate" ref="a222df3db3c9d5b24d1a4d4d9e8d5bd1b" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist.html">list</a>* list_duplicate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicate a linked <a class="el" href="structlist.html">list</a> Returns a copy of the linked <a class="el" href="structlist.html">list</a>. </p>
<p>Note that the pointers in both lists point to the same places. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to be duplicated </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the duplicate <a class="el" href="structlist.html">list</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5fdf1a904264be077ce19a432b1b119"></a><!-- doxytag: member="list.h::list_delete" ref="ab5fdf1a904264be077ce19a432b1b119" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a linked <a class="el" href="structlist.html">list</a>. </p>
<p>Note that this function only deletes the <a class="el" href="structlist.html">list</a> itself, it does not delete the items referred to by the <a class="el" href="structlist.html">list</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82587229be89a53219c37bc68ee973f6"></a><!-- doxytag: member="list.h::list_free" ref="a82587229be89a53219c37bc68ee973f6" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free every item referred to by the <a class="el" href="structlist.html">list</a>. </p>
<p>Note that this function does not delete the <a class="el" href="structlist.html">list</a> itself. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1636df82df6c1fd784f6ca3afd32d1f"></a><!-- doxytag: member="list.h::list_splice" ref="ad1636df82df6c1fd784f6ca3afd32d1f" args="(struct list *top, struct list *bottom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist.html">list</a>* list_splice </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>bottom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splice two lists together. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>top</em>&nbsp;</td><td>A linked <a class="el" href="structlist.html">list</a> that will be destroyed in the process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bottom</em>&nbsp;</td><td>A linked <a class="el" href="structlist.html">list</a> that will be destroyed in the process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new linked <a class="el" href="structlist.html">list</a> with elements from top at the head and bottom at the tail. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b3b19c22b3b693bc16efafda2d57d88"></a><!-- doxytag: member="list.h::list_split" ref="a2b3b19c22b3b693bc16efafda2d57d88" args="(struct list *src, list_op_t cmp, const void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist.html">list</a>* list_split </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_op_t&nbsp;</td>
          <td class="paramname"> <em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a <a class="el" href="structlist.html">list</a> into two at the given item If arg is NULL or not found, list_split returns NULL and the <a class="el" href="structlist.html">list</a> is unaffected. </p>
<p>Otherwise src will contain all elements [src-&gt;head, arg) and a new <a class="el" href="structlist.html">list</a> will be created with all elements [arg, src-&gt;tail]. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The linked <a class="el" href="structlist.html">list</a> to be split </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmp</em>&nbsp;</td><td>The comparison function. Should return non-zero on a match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>The data element to split on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new linked <a class="el" href="structlist.html">list</a> with arg as the head and all elements after arg as elements of the new <a class="el" href="structlist.html">list</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1ab4538dda5826f75c4b31e3bc12d6c"></a><!-- doxytag: member="list.h::list_size" ref="ac1ab4538dda5826f75c4b31e3bc12d6c" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the elements in a <a class="el" href="structlist.html">list</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of items stored in the <a class="el" href="structlist.html">list</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9179a4dcfa933c42fba5290f5e4f5614"></a><!-- doxytag: member="list.h::list_push_priority" ref="a9179a4dcfa933c42fba5290f5e4f5614" args="(struct list *list, void *item, int prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_push_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push an item in priority order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to push onto. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item to push onto the <a class="el" href="structlist.html">list</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The integer priority of the item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false on failure (due to out of memory.) </dd></dl>

</div>
</div>
<a class="anchor" id="ab9fa977fbbaed21f9d745c7810145d3d"></a><!-- doxytag: member="list.h::list_push_head" ref="ab9fa977fbbaed21f9d745c7810145d3d" args="(struct list *list, void *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_push_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push an item onto the <a class="el" href="structlist.html">list</a> head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to push onto. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item to push onto the <a class="el" href="structlist.html">list</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false on failure (due to out of memory.) </dd></dl>

</div>
</div>
<a class="anchor" id="a66aea0e0d2a269e7802b0fcdc4e29527"></a><!-- doxytag: member="list.h::list_pop_head" ref="a66aea0e0d2a269e7802b0fcdc4e29527" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_pop_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pop an item off of the <a class="el" href="structlist.html">list</a> head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item popped, or null if <a class="el" href="structlist.html">list</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a10268615c649d4f981662a6feed9c9ad"></a><!-- doxytag: member="list.h::list_peek_head" ref="a10268615c649d4f981662a6feed9c9ad" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_peek_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at the <a class="el" href="structlist.html">list</a> head. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to peek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item at the <a class="el" href="structlist.html">list</a> head, or null if <a class="el" href="structlist.html">list</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ad01ebcdcfec40d1949d41a6a7bce27ad"></a><!-- doxytag: member="list.h::list_push_tail" ref="ad01ebcdcfec40d1949d41a6a7bce27ad" args="(struct list *list, void *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_push_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push an item onto the <a class="el" href="structlist.html">list</a> tail. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to push onto. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item to push onto the <a class="el" href="structlist.html">list</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success, false on failure (due to out of memory.) </dd></dl>

</div>
</div>
<a class="anchor" id="a3bf0ceb2176fa239e2cb36a15d444849"></a><!-- doxytag: member="list.h::list_pop_tail" ref="a3bf0ceb2176fa239e2cb36a15d444849" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_pop_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pop an item off of the <a class="el" href="structlist.html">list</a> tail. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to pop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item popped, or null if <a class="el" href="structlist.html">list</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aef4649894f08ae98b870124c4098160b"></a><!-- doxytag: member="list.h::list_peek_tail" ref="aef4649894f08ae98b870124c4098160b" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_peek_tail </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at the <a class="el" href="structlist.html">list</a> tail. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to peek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item at the <a class="el" href="structlist.html">list</a> tail, or null if <a class="el" href="structlist.html">list</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e2d70ea2fa24cbf13bad4676427214b"></a><!-- doxytag: member="list.h::list_peek_current" ref="a3e2d70ea2fa24cbf13bad4676427214b" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_peek_current </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at the current element in the iteration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to peek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The item at the <a class="el" href="structlist.html">list</a> head, or null if <a class="el" href="structlist.html">list</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ac19d222298487ce12b445def0b1cf55e"></a><!-- doxytag: member="list.h::list_find" ref="ac19d222298487ce12b445def0b1cf55e" args="(struct list *list, list_op_t cmp, const void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_find </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_op_t&nbsp;</td>
          <td class="paramname"> <em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find an element within a <a class="el" href="structlist.html">list</a> This function searches the <a class="el" href="structlist.html">list</a>, comparing each element in the <a class="el" href="structlist.html">list</a> to arg, and returns a pointer to the first matching element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmp</em>&nbsp;</td><td>The comparison function. Should return non-zero on a match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>The element to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the first matched element, or NULL if no elements match. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a04edf349230926222efa9c209b85d4"></a><!-- doxytag: member="list.h::list_remove" ref="a7a04edf349230926222efa9c209b85d4" args="(struct list *list, const void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an item from the <a class="el" href="structlist.html">list</a> This function searches the <a class="el" href="structlist.html">list</a> for the item pointed to by value and removes it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The item to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The removed item. </dd></dl>

</div>
</div>
<a class="anchor" id="a85f7c1280b012f5ce53f245894835c67"></a><!-- doxytag: member="list.h::list_first_item" ref="a85f7c1280b012f5ce53f245894835c67" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_first_item </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin traversing a <a class="el" href="structlist.html">list</a>. </p>
<p>This function sets the internal <a class="el" href="structlist.html">list</a> iterator to the first item. Call <a class="el" href="list_8h.html#a508716109f6c47dd73b3b07b411425f6">list_next_item</a> to begin returning the items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to traverse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a508716109f6c47dd73b3b07b411425f6"></a><!-- doxytag: member="list.h::list_next_item" ref="a508716109f6c47dd73b3b07b411425f6" args="(struct list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_next_item </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Continue traversing a <a class="el" href="structlist.html">list</a>. </p>
<p>This function returns the current <a class="el" href="structlist.html">list</a> item, and advances the internal iterator to the next item. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current item in the <a class="el" href="structlist.html">list</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a04051f7b784370d26615dcab371cca8e"></a><!-- doxytag: member="list.h::list_iterate" ref="a04051f7b784370d26615dcab371cca8e" args="(struct list *list, list_op_t op, const void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_iterate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_op_t&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a function to a <a class="el" href="structlist.html">list</a>. </p>
<p>Invokes op on every member of the <a class="el" href="structlist.html">list</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operator to apply. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional parameter to send to op. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ca1a102b90872fe07b043f07a7c6f7c"></a><!-- doxytag: member="list.h::list_iterate_reverse" ref="a9ca1a102b90872fe07b043f07a7c6f7c" args="(struct list *list, list_op_t op, const void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_iterate_reverse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list_op_t&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a function to a <a class="el" href="structlist.html">list</a> in reverse. </p>
<p>Invokes op on every member of the <a class="el" href="structlist.html">list</a> in reverse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The operator to apply. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>An optional parameter to send to op. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a181680b0cc667bd5e812f33802284c"></a><!-- doxytag: member="list.h::list_sort" ref="a9a181680b0cc667bd5e812f33802284c" args="(struct list *list, int(*comparator)(const void *, const void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist.html">list</a>* list_sort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&nbsp;</td>
          <td class="paramname"> <em>comparator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort a <a class="el" href="structlist.html">list</a> using a comparator function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structlist.html">list</a></em>&nbsp;</td><td>The <a class="el" href="structlist.html">list</a> to sort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comparator</em>&nbsp;</td><td>The comparison function used in the sort. The function should take in pointers to two objects casted as void* and return an integer indicating whether the first is less than (negative), equal to (0), or greater than (positive) the second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="structlist.html">list</a> passed in. Identical to the <a class="el" href="structlist.html">list</a> parameter. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 10 Jul 2014 for cctools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
