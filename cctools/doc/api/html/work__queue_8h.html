<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cctools: work_queue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_b4595bd0bcd63441b4e2a9024dab2403.html">work_queue</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_54b252d424f454f174d113a42c155eba.html">src</a>
  </div>
</div>
<div class="contents">
<h1>work_queue.h File Reference</h1>
<p>A master-worker library.  
<a href="#_details">More...</a></p>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="timestamp_8h_source.html">timestamp.h</a>&quot;</code><br/>

<p><a href="work__queue_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwork__queue__task.html">work_queue_task</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A task description.  <a href="structwork__queue__task.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwork__queue__stats.html">work_queue_stats</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics describing a work queue.  <a href="structwork__queue__stats.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a603414c07950e859deb01e04e982f73e">WORK_QUEUE_DEFAULT_PORT</a>&nbsp;&nbsp;&nbsp;9123</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Work Queue port number.  <a href="#a603414c07950e859deb01e04e982f73e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a68c9fe77b1de10cb83f4945ffd3b4fec">WORK_QUEUE_RANDOM_PORT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that any port number may be chosen.  <a href="#a68c9fe77b1de10cb83f4945ffd3b4fec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a3cde1d463fec81eca0b4ced4fc1dc01e">WORK_QUEUE_WAITFORTASK</a>&nbsp;&nbsp;&nbsp;-1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a task to complete before returning.  <a href="#a3cde1d463fec81eca0b4ced4fc1dc01e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a1d1e09654125343a67426ee1f01e20b2">WORK_QUEUE_SCHEDULE_FCFS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select worker on a first-come-first-serve basis.  <a href="#a1d1e09654125343a67426ee1f01e20b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ae25ae070d802ac0d66e00ef65b11c270">WORK_QUEUE_SCHEDULE_FILES</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select worker that has the most data required by the task.  <a href="#ae25ae070d802ac0d66e00ef65b11c270"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a6e4eb36aa7ef72d9e52886824f918e16">WORK_QUEUE_SCHEDULE_TIME</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select worker that has the fastest execution time on previous tasks.  <a href="#a6e4eb36aa7ef72d9e52886824f918e16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a7d079059081c4815b82f911ca4de2cdd">WORK_QUEUE_SCHEDULE_RAND</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select a random worker.  <a href="#a7d079059081c4815b82f911ca4de2cdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ac00bd222bb7bb2b03017de2c25801ccd">WORK_QUEUE_TASK_ORDER_FIFO</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve tasks based on first-in-first-out order.  <a href="#ac00bd222bb7bb2b03017de2c25801ccd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a801aded6c67da94d5c9c85fd3dffdbc4">WORK_QUEUE_TASK_ORDER_LIFO</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve tasks based on last-in-first-out order.  <a href="#a801aded6c67da94d5c9c85fd3dffdbc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#aec8d5ed52852a8dd772a6d6a362667af">WORK_QUEUE_INPUT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify an input object.  <a href="#aec8d5ed52852a8dd772a6d6a362667af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ad62dbab142c500d243cebd796053ccf5">WORK_QUEUE_OUTPUT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify an output object.  <a href="#ad62dbab142c500d243cebd796053ccf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a5a4dc8d3ae3c734ea348c4e07bbe3451">WORK_QUEUE_NOCACHE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do not cache file at execution site.  <a href="#a5a4dc8d3ae3c734ea348c4e07bbe3451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a36066dcb0622e6a19a31da1c8a219d57">WORK_QUEUE_CACHE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache file at execution site for later use.  <a href="#a36066dcb0622e6a19a31da1c8a219d57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a21f94beb13470cc040a3854d6422bde0">WORK_QUEUE_WATCH</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Watch the output file and send back changes as the task runs.  <a href="#a21f94beb13470cc040a3854d6422bde0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#add229725a960de4aa028703218a74f60">WORK_QUEUE_RESET_ALL</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When resetting, clear out all tasks and files.  <a href="#add229725a960de4aa028703218a74f60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a29f131dd172432c681a98d16a92a3ac1">WORK_QUEUE_RESET_KEEP_TASKS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When resetting, keep the current <a class="el" href="structlist.html">list</a> of tasks.  <a href="#a29f131dd172432c681a98d16a92a3ac1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#acadd761b66406a78be3120e357a682f9">WORK_QUEUE_DEFAULT_KEEPALIVE_INTERVAL</a>&nbsp;&nbsp;&nbsp;300</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for Work Queue keepalive interval in seconds.  <a href="#acadd761b66406a78be3120e357a682f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a7316047eb1f8b021ae06b90c605b251b">WORK_QUEUE_DEFAULT_KEEPALIVE_TIMEOUT</a>&nbsp;&nbsp;&nbsp;30</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value for Work Queue keepalive timeout in seconds.  <a href="#a7316047eb1f8b021ae06b90c605b251b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a47f0a21575b250991e97a70830143cc8">WORK_QUEUE_RESULT_SUCCESS</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The task ran successfully &gt;.  <a href="#a47f0a21575b250991e97a70830143cc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#aa144173e105ca9de33f8e5c418c1a4ca">WORK_QUEUE_RESULT_INPUT_MISSING</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The task cannot be run due to a missing input file &gt;.  <a href="#aa144173e105ca9de33f8e5c418c1a4ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a07265ae211d9ff83709ec5013e4fbd89">WORK_QUEUE_RESULT_OUTPUT_MISSING</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The task ran but failed to generate a specified output file &gt;.  <a href="#a07265ae211d9ff83709ec5013e4fbd89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a5a4ad815e263874b829f93e7b86eeaa4">WORK_QUEUE_RESULT_STDOUT_MISSING</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The task ran but its stdout has been truncated &gt;.  <a href="#a5a4ad815e263874b829f93e7b86eeaa4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions - Tasks</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp11825a8913945d477b240452e31ef519"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ad1343a34f7792d877bcc79a84bb436fd">work_queue_task_create</a> (const char *full_command)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new task object.  <a href="#ad1343a34f7792d877bcc79a84bb436fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ac5bf776a2ba3b382004ca338f81d464a">work_queue_task_clone</a> (const struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *task)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a copy of a task Create a functionally identical copy of a <a class="el" href="structwork__queue__task.html">work_queue_task</a> that can be re-submitted via <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>.  <a href="#ac5bf776a2ba3b382004ca338f81d464a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a4df1ecdd4ac3d9d255efca68883a7f4c">work_queue_task_specify_command</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *cmd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate the command to be executed.  <a href="#a4df1ecdd4ac3d9d255efca68883a7f4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a3070da55a7fe72f8cab43f81cdc07df4">work_queue_task_specify_file</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *local_name, const char *remote_name, int type, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a file to a task.  <a href="#a3070da55a7fe72f8cab43f81cdc07df4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a27b363d1a11757c6cb7ddad281fa5e63">work_queue_task_specify_file_piece</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *local_name, const char *remote_name, off_t start_byte, off_t end_byte, int type, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a file piece to a task.  <a href="#a27b363d1a11757c6cb7ddad281fa5e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a10574c7cafdeaaef66a5962b63991920">work_queue_task_specify_buffer</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *data, int length, const char *remote_name, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an input <a class="el" href="structbuffer.html">buffer</a> to a task.  <a href="#a10574c7cafdeaaef66a5962b63991920"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a243c871c96f08380b893e2ea63b0072d">work_queue_task_specify_directory</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *local_name, const char *remote_name, int type, int flags, int recursive)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a directory to a task.  <a href="#a243c871c96f08380b893e2ea63b0072d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a5203f51a095525a37d8b4c3428779a5a">work_queue_task_specify_memory</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, int64_t memory)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the amount of memory required by a task.  <a href="#a5203f51a095525a37d8b4c3428779a5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ade6a0fa5ed42d7b82f82c82336e748b0">work_queue_task_specify_disk</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, int64_t disk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the amount of disk space required by a task.  <a href="#ade6a0fa5ed42d7b82f82c82336e748b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#abdd8963575b294e703b79c3655de426c">work_queue_task_specify_cores</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, int cores)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the number of cores required by a task.  <a href="#abdd8963575b294e703b79c3655de426c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a6a572c831f87b142f96f764a640eef67">work_queue_task_specify_gpus</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, int gpus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the number of gpus required by a task.  <a href="#a6a572c831f87b142f96f764a640eef67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a2e68c00abc2afe0a93649d67e863b848">work_queue_task_specify_tag</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach a user defined string tag to the task.  <a href="#a2e68c00abc2afe0a93649d67e863b848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a7872d78c93ce446a29d5646164b61b66">work_queue_task_specify_algorithm</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, int algo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select the scheduling algorithm for a single task.  <a href="#a7872d78c93ce446a29d5646164b61b66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#aabb0948d8e71e97ee786d636d8fca5ab">work_queue_task_delete</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a task.  <a href="#aabb0948d8e71e97ee786d636d8fca5ab"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions - Queues</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpeb562c77d770069d4e50794e61f32c67"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct work_queue *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a21714a10bcdfcf5c3bd44a96f5dcbda6">work_queue_create</a> (int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new work queue.  <a href="#a21714a10bcdfcf5c3bd44a96f5dcbda6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a9b0b3e49fc5c92d2c0c2c912f7d51807">work_queue_enable_monitoring</a> (struct work_queue *q, char *monitor_summary_file)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables resource monitoring on the give work queue.  <a href="#a9b0b3e49fc5c92d2c0c2c912f7d51807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a> (struct work_queue *q, struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a task to a queue.  <a href="#ac52e29cbe5c3137fdae20871156367df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a8d31286dc2c8b5b1c8ac466116600501">work_queue_blacklist_add</a> (struct work_queue *q, const char *hostname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blacklist host from a queue.  <a href="#a8d31286dc2c8b5b1c8ac466116600501"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ab781f82af02fb0ba02e3a711644e847d">work_queue_blacklist_remove</a> (struct work_queue *q, const char *hostname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblacklist host from a queue.  <a href="#ab781f82af02fb0ba02e3a711644e847d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a188e3cf78af6059b069593df402f16f7">work_queue_blacklist_clear</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear blacklist of a queue.  <a href="#a188e3cf78af6059b069593df402f16f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#afd6ce91a68a5d68e423058bd876c98d2">work_queue_wait</a> (struct work_queue *q, int timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a task to complete.  <a href="#afd6ce91a68a5d68e423058bd876c98d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#afb70bbdb96e69717acd2d53554171d5c">work_queue_hungry</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the queue is 'hungry' for more tasks.  <a href="#afb70bbdb96e69717acd2d53554171d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a825de0cbb8b3bf49b936d697d85e6157">work_queue_empty</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the queue is empty.  <a href="#a825de0cbb8b3bf49b936d697d85e6157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a087c13d03449c9746c3c73674a594e23">work_queue_port</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the listening port of the queue.  <a href="#a087c13d03449c9746c3c73674a594e23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a8eb8088ee337106351c8646adc319de8">work_queue_get_stats</a> (struct work_queue *q, struct <a class="el" href="structwork__queue__stats.html">work_queue_stats</a> *s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get queue statistics.  <a href="#a8eb8088ee337106351c8646adc319de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a6e423e16717e69b6ba9a268dee378a22">work_queue_set_bandwidth_limit</a> (struct work_queue *q, const char *bandwidth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit the queue bandwidth when transferring files to and from workers.  <a href="#a6e423e16717e69b6ba9a268dee378a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a836f1cfa0e8b742f7c311e2664f7f6dd">work_queue_get_effective_bandwidth</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current queue bandwidth.  <a href="#a836f1cfa0e8b742f7c311e2664f7f6dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a95bf1d7e3df002fde7cc09c88dd7737f">work_queue_get_worker_summary</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Summarize workers.  <a href="#a95bf1d7e3df002fde7cc09c88dd7737f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ab14593aa7b1d2afbeef2c88799e02ba6">work_queue_activate_fast_abort</a> (struct work_queue *q, double multiplier)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn on or off fast abort functionality for a given queue.  <a href="#ab14593aa7b1d2afbeef2c88799e02ba6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a2c25df729311b3ece2aeaf1a50bf72c6">work_queue_specify_algorithm</a> (struct work_queue *q, int algo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the worker selection algorithm.  <a href="#a2c25df729311b3ece2aeaf1a50bf72c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#af911446b986bfc87d0e88c826ab19475">work_queue_specify_task_order</a> (struct work_queue *q, int order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify how the submitted tasks should be ordered.  <a href="#af911446b986bfc87d0e88c826ab19475"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a26ec8254fe6499ccf5c530bf8730c653">work_queue_name</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the project name of the queue.  <a href="#a26ec8254fe6499ccf5c530bf8730c653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a1a6f846a7966797554670c869a2a3a9b">work_queue_specify_name</a> (struct work_queue *q, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the project name for a given queue.  <a href="#a1a6f846a7966797554670c869a2a3a9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a62e07e64203ac185279fae6b6952de11">work_queue_specify_priority</a> (struct work_queue *q, int priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the priority for a given queue.  <a href="#a62e07e64203ac185279fae6b6952de11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#aa7291e2c8fe58f79364111428636286b">work_queue_specify_catalog_server</a> (struct work_queue *q, const char *hostname, int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the catalog server the master should report to.  <a href="#aa7291e2c8fe58f79364111428636286b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ac94746fc9c8206f8f003878e40e9030b">work_queue_cancel_by_taskid</a> (struct work_queue *q, int id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a submitted task using its task id and remove it from queue.  <a href="#ac94746fc9c8206f8f003878e40e9030b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ae4998d3840cfd83cdbfc522d4870464f">work_queue_cancel_by_tasktag</a> (struct work_queue *q, const char *tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a submitted task using its tag and remove it from queue.  <a href="#ae4998d3840cfd83cdbfc522d4870464f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structlist.html">list</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#aab4002baf71625fc68f4507dee61f0b0">work_queue_cancel_all_tasks</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all submitted tasks and remove them from the queue.  <a href="#aab4002baf71625fc68f4507dee61f0b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ac8a7df762311589c0e9c91b13f6d4e80">work_queue_shut_down_workers</a> (struct work_queue *q, int n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down workers connected to the work_queue system.  <a href="#ac8a7df762311589c0e9c91b13f6d4e80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a4a292be23ed3988cc9e92389f8356b6b">work_queue_delete</a> (struct work_queue *q)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a work queue.  <a href="#a4a292be23ed3988cc9e92389f8356b6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a9159948b43e9ec25e4b21cc985562eea">work_queue_specify_log</a> (struct work_queue *q, const char *logfile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a log file that records the states of the connected workers and submitted tasks.  <a href="#a9159948b43e9ec25e4b21cc985562eea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a43027dbf0cc845a9a62eda7829f19ba4">work_queue_specify_password</a> (struct work_queue *q, const char *password)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a mandatory password that each worker must present.  <a href="#a43027dbf0cc845a9a62eda7829f19ba4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#af1d9f0f8bb84829a43a2c404c57a213b">work_queue_specify_password_file</a> (struct work_queue *q, const char *file)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a mandatory password file that each worker must present.  <a href="#af1d9f0f8bb84829a43a2c404c57a213b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a3f46688fe5c9d5c09ada61620cf1a309">work_queue_specify_keepalive_interval</a> (struct work_queue *q, int interval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the keepalive interval for a given queue.  <a href="#a3f46688fe5c9d5c09ada61620cf1a309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a2f9be386cae7b3282a4060361b8a7efb">work_queue_specify_keepalive_timeout</a> (struct work_queue *q, int timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the keepalive timeout for identifying dead workers for a given queue.  <a href="#a2f9be386cae7b3282a4060361b8a7efb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a493c353e1aca544f43b1cda35a80eea0">work_queue_tune</a> (struct work_queue *q, const char *name, double value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tune advanced parameters for work queue.  <a href="#a493c353e1aca544f43b1cda35a80eea0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a347c0916bec6201436bb7618b5a46d0c">wq_option_fast_abort_multiplier</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial setting for fast abort multiplier upon creating queue.  <a href="#a347c0916bec6201436bb7618b5a46d0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a564c89add39f633ca105efd223d44846">wq_option_scheduler</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial setting for algorithm to assign tasks to workers upon creating queue .  <a href="#a564c89add39f633ca105efd223d44846"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions - Deprecated</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbd656f9518e2500f5c212ba87c880a4a"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a4c83ef0763b818c5479ae652a1476798">WORK_QUEUE_MASTER_MODE_STANDALONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work Queue master does not report to the catalog server.  <a href="#a4c83ef0763b818c5479ae652a1476798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a763c12b05763df694f7519a8fd56c35d">WORK_QUEUE_MASTER_MODE_CATALOG</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work Queue master reports to catalog server.  <a href="#a763c12b05763df694f7519a8fd56c35d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a36592ac2e2959acb7d6976bc96d6d707">work_queue_specify_master_mode</a> (struct work_queue *q, int mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the master mode for a given queue.  <a href="#a36592ac2e2959acb7d6976bc96d6d707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a26ecb96db8972ec708f896d0f7d53807">work_queue_specify_estimate_capacity_on</a> (struct work_queue *q, int estimate_capacity_on)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change whether to estimate master capacity for a given queue.  <a href="#a26ecb96db8972ec708f896d0f7d53807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#ae2b5e1955e01a4d17c6d8cf9d54870e7">work_queue_task_specify_input_buf</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *buf, int length, const char *rname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an input <a class="el" href="structbuffer.html">buffer</a> to a task.  <a href="#ae2b5e1955e01a4d17c6d8cf9d54870e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a2b4f1fb3167f8d754f435462b09e334e">work_queue_task_specify_input_file</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *fname, const char *rname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an input file to a task.  <a href="#a2b4f1fb3167f8d754f435462b09e334e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#aa9b4aed8e4d44f1f0788db3c7c523065">work_queue_task_specify_input_file_do_not_cache</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *fname, const char *rname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an input file to a task, without caching.  <a href="#aa9b4aed8e4d44f1f0788db3c7c523065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#a8e896ccd2e2fb6c95f9e3f32ed52348d">work_queue_task_specify_output_file</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *rname, const char *fname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an output file to a task.  <a href="#a8e896ccd2e2fb6c95f9e3f32ed52348d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="work__queue_8h.html#acf60cabad0fa573953a782cf6e4676f5">work_queue_task_specify_output_file_do_not_cache</a> (struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *t, const char *rname, const char *fname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an output file to a task without caching.  <a href="#acf60cabad0fa573953a782cf6e4676f5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A master-worker library. </p>
<p>The work queue provides an implementation of the master-worker computing model using TCP sockets, Unix applications, and files as intermediate buffers. A master process uses <a class="el" href="work__queue_8h.html#a21714a10bcdfcf5c3bd44a96f5dcbda6">work_queue_create</a> to create a queue, then <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a> to submit tasks. Once tasks are running, call <a class="el" href="work__queue_8h.html#afd6ce91a68a5d68e423058bd876c98d2">work_queue_wait</a> to wait for completion. A generic worker program, named <code>work_queue_worker</code>, can be run on any machine, and simply needs to be told the host and port of the master. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a603414c07950e859deb01e04e982f73e"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_DEFAULT_PORT" ref="a603414c07950e859deb01e04e982f73e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_DEFAULT_PORT&nbsp;&nbsp;&nbsp;9123</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Work Queue port number. </p>

</div>
</div>
<a class="anchor" id="a68c9fe77b1de10cb83f4945ffd3b4fec"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RANDOM_PORT" ref="a68c9fe77b1de10cb83f4945ffd3b4fec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RANDOM_PORT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that any port number may be chosen. </p>

</div>
</div>
<a class="anchor" id="a3cde1d463fec81eca0b4ced4fc1dc01e"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_WAITFORTASK" ref="a3cde1d463fec81eca0b4ced4fc1dc01e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_WAITFORTASK&nbsp;&nbsp;&nbsp;-1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a task to complete before returning. </p>

</div>
</div>
<a class="anchor" id="a1d1e09654125343a67426ee1f01e20b2"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_SCHEDULE_FCFS" ref="a1d1e09654125343a67426ee1f01e20b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_SCHEDULE_FCFS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select worker on a first-come-first-serve basis. </p>

</div>
</div>
<a class="anchor" id="ae25ae070d802ac0d66e00ef65b11c270"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_SCHEDULE_FILES" ref="ae25ae070d802ac0d66e00ef65b11c270" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_SCHEDULE_FILES&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select worker that has the most data required by the task. </p>

</div>
</div>
<a class="anchor" id="a6e4eb36aa7ef72d9e52886824f918e16"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_SCHEDULE_TIME" ref="a6e4eb36aa7ef72d9e52886824f918e16" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_SCHEDULE_TIME&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select worker that has the fastest execution time on previous tasks. </p>

</div>
</div>
<a class="anchor" id="a7d079059081c4815b82f911ca4de2cdd"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_SCHEDULE_RAND" ref="a7d079059081c4815b82f911ca4de2cdd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_SCHEDULE_RAND&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select a random worker. </p>

</div>
</div>
<a class="anchor" id="ac00bd222bb7bb2b03017de2c25801ccd"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_TASK_ORDER_FIFO" ref="ac00bd222bb7bb2b03017de2c25801ccd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_TASK_ORDER_FIFO&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve tasks based on first-in-first-out order. </p>

</div>
</div>
<a class="anchor" id="a801aded6c67da94d5c9c85fd3dffdbc4"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_TASK_ORDER_LIFO" ref="a801aded6c67da94d5c9c85fd3dffdbc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_TASK_ORDER_LIFO&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve tasks based on last-in-first-out order. </p>

</div>
</div>
<a class="anchor" id="aec8d5ed52852a8dd772a6d6a362667af"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_INPUT" ref="aec8d5ed52852a8dd772a6d6a362667af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_INPUT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify an input object. </p>

</div>
</div>
<a class="anchor" id="ad62dbab142c500d243cebd796053ccf5"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_OUTPUT" ref="ad62dbab142c500d243cebd796053ccf5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_OUTPUT&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify an output object. </p>

</div>
</div>
<a class="anchor" id="a5a4dc8d3ae3c734ea348c4e07bbe3451"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_NOCACHE" ref="a5a4dc8d3ae3c734ea348c4e07bbe3451" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_NOCACHE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do not cache file at execution site. </p>

</div>
</div>
<a class="anchor" id="a36066dcb0622e6a19a31da1c8a219d57"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_CACHE" ref="a36066dcb0622e6a19a31da1c8a219d57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_CACHE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cache file at execution site for later use. </p>

</div>
</div>
<a class="anchor" id="a21f94beb13470cc040a3854d6422bde0"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_WATCH" ref="a21f94beb13470cc040a3854d6422bde0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_WATCH&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Watch the output file and send back changes as the task runs. </p>

</div>
</div>
<a class="anchor" id="add229725a960de4aa028703218a74f60"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RESET_ALL" ref="add229725a960de4aa028703218a74f60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RESET_ALL&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When resetting, clear out all tasks and files. </p>

</div>
</div>
<a class="anchor" id="a29f131dd172432c681a98d16a92a3ac1"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RESET_KEEP_TASKS" ref="a29f131dd172432c681a98d16a92a3ac1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RESET_KEEP_TASKS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When resetting, keep the current <a class="el" href="structlist.html">list</a> of tasks. </p>

</div>
</div>
<a class="anchor" id="acadd761b66406a78be3120e357a682f9"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_DEFAULT_KEEPALIVE_INTERVAL" ref="acadd761b66406a78be3120e357a682f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_DEFAULT_KEEPALIVE_INTERVAL&nbsp;&nbsp;&nbsp;300</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default value for Work Queue keepalive interval in seconds. </p>

</div>
</div>
<a class="anchor" id="a7316047eb1f8b021ae06b90c605b251b"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_DEFAULT_KEEPALIVE_TIMEOUT" ref="a7316047eb1f8b021ae06b90c605b251b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_DEFAULT_KEEPALIVE_TIMEOUT&nbsp;&nbsp;&nbsp;30</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default value for Work Queue keepalive timeout in seconds. </p>

</div>
</div>
<a class="anchor" id="a47f0a21575b250991e97a70830143cc8"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RESULT_SUCCESS" ref="a47f0a21575b250991e97a70830143cc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RESULT_SUCCESS&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The task ran successfully &gt;. </p>

</div>
</div>
<a class="anchor" id="aa144173e105ca9de33f8e5c418c1a4ca"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RESULT_INPUT_MISSING" ref="aa144173e105ca9de33f8e5c418c1a4ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RESULT_INPUT_MISSING&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The task cannot be run due to a missing input file &gt;. </p>

</div>
</div>
<a class="anchor" id="a07265ae211d9ff83709ec5013e4fbd89"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RESULT_OUTPUT_MISSING" ref="a07265ae211d9ff83709ec5013e4fbd89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RESULT_OUTPUT_MISSING&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The task ran but failed to generate a specified output file &gt;. </p>

</div>
</div>
<a class="anchor" id="a5a4ad815e263874b829f93e7b86eeaa4"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_RESULT_STDOUT_MISSING" ref="a5a4ad815e263874b829f93e7b86eeaa4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_RESULT_STDOUT_MISSING&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The task ran but its stdout has been truncated &gt;. </p>

</div>
</div>
<a class="anchor" id="a4c83ef0763b818c5479ae652a1476798"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_MASTER_MODE_STANDALONE" ref="a4c83ef0763b818c5479ae652a1476798" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_MASTER_MODE_STANDALONE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Work Queue master does not report to the catalog server. </p>

</div>
</div>
<a class="anchor" id="a763c12b05763df694f7519a8fd56c35d"></a><!-- doxytag: member="work_queue.h::WORK_QUEUE_MASTER_MODE_CATALOG" ref="a763c12b05763df694f7519a8fd56c35d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WORK_QUEUE_MASTER_MODE_CATALOG&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Work Queue master reports to catalog server. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad1343a34f7792d877bcc79a84bb436fd"></a><!-- doxytag: member="work_queue.h::work_queue_task_create" ref="ad1343a34f7792d877bcc79a84bb436fd" args="(const char *full_command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a>* work_queue_task_create </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>full_command</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new task object. </p>
<p>Once created and elaborated with functions such as <a class="el" href="work__queue_8h.html#a3070da55a7fe72f8cab43f81cdc07df4">work_queue_task_specify_file</a> and <a class="el" href="work__queue_8h.html#a10574c7cafdeaaef66a5962b63991920">work_queue_task_specify_buffer</a>, the task should be passed to <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>full_command</em>&nbsp;</td><td>The shell command line to be executed by the task. If null, the command will be given later by <a class="el" href="work__queue_8h.html#a4df1ecdd4ac3d9d255efca68883a7f4c">work_queue_task_specify_command</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new task object, or null if it could not be created. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5bf776a2ba3b382004ca338f81d464a"></a><!-- doxytag: member="work_queue.h::work_queue_task_clone" ref="ac5bf776a2ba3b382004ca338f81d464a" args="(const struct work_queue_task *task)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a>* work_queue_task_clone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>task</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a copy of a task Create a functionally identical copy of a <a class="el" href="structwork__queue__task.html">work_queue_task</a> that can be re-submitted via <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new task object </dd></dl>

</div>
</div>
<a class="anchor" id="a4df1ecdd4ac3d9d255efca68883a7f4c"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_command" ref="a4df1ecdd4ac3d9d255efca68883a7f4c" args="(struct work_queue_task *t, const char *cmd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_command </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cmd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate the command to be executed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>The command to be executed. This string will be duplicated by this call, so the argument may be freed or re-used afterward. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3070da55a7fe72f8cab43f81cdc07df4"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_file" ref="a3070da55a7fe72f8cab43f81cdc07df4" args="(struct work_queue_task *t, const char *local_name, const char *remote_name, int type, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>local_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>remote_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a file to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local_name</em>&nbsp;</td><td>The name of the file on local disk or shared filesystem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remote_name</em>&nbsp;</td><td>The name of the file at the remote execution site. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Must be one of the following values:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#aec8d5ed52852a8dd772a6d6a362667af">WORK_QUEUE_INPUT</a> to indicate an input file to be consumed by the task</li>
<li><a class="el" href="work__queue_8h.html#ad62dbab142c500d243cebd796053ccf5">WORK_QUEUE_OUTPUT</a> to indicate an output file to be produced by the task </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>May be zero to indicate no special handling or any of the following or'd together:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a36066dcb0622e6a19a31da1c8a219d57">WORK_QUEUE_CACHE</a> indicates that the file should be cached for later tasks. (recommended)</li>
<li><a class="el" href="work__queue_8h.html#a5a4dc8d3ae3c734ea348c4e07bbe3451">WORK_QUEUE_NOCACHE</a> indicates that the file should not be cached for later tasks.</li>
<li><a class="el" href="work__queue_8h.html#a21f94beb13470cc040a3854d6422bde0">WORK_QUEUE_WATCH</a> indicates that the worker will watch the output file as it is created and incrementally return the file to the master as the task runs. (The frequency of these updates is entirely dependent upon the system load. If the master is busy interacting with many workers, output updates will be infrequent.) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the task file is successfully specified, 0 if either of <em>t</em>, <em>local_name</em>, or <em>remote_name</em> is null or <em>remote_name</em> is an absolute path. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b363d1a11757c6cb7ddad281fa5e63"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_file_piece" ref="a27b363d1a11757c6cb7ddad281fa5e63" args="(struct work_queue_task *t, const char *local_name, const char *remote_name, off_t start_byte, off_t end_byte, int type, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_file_piece </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>local_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>remote_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&nbsp;</td>
          <td class="paramname"> <em>start_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&nbsp;</td>
          <td class="paramname"> <em>end_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a file piece to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local_name</em>&nbsp;</td><td>The name of the file on local disk or shared filesystem. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remote_name</em>&nbsp;</td><td>The name of the file at the remote execution site. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_byte</em>&nbsp;</td><td>The starting byte offset of the file piece to be transferred. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end_byte</em>&nbsp;</td><td>The ending byte offset of the file piece to be transferred. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Must be one of the following values:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#aec8d5ed52852a8dd772a6d6a362667af">WORK_QUEUE_INPUT</a> to indicate an input file to be consumed by the task</li>
<li><a class="el" href="work__queue_8h.html#ad62dbab142c500d243cebd796053ccf5">WORK_QUEUE_OUTPUT</a> to indicate an output file to be produced by the task </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>May be zero to indicate no special handling or any of the following or'd together:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a36066dcb0622e6a19a31da1c8a219d57">WORK_QUEUE_CACHE</a> indicates that the file should be cached for later tasks. (recommended)</li>
<li><a class="el" href="work__queue_8h.html#a5a4dc8d3ae3c734ea348c4e07bbe3451">WORK_QUEUE_NOCACHE</a> indicates that the file should not be cached for later tasks. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the task file piece is successfully specified, 0 if either of <em>t</em>, <em>local_name</em>, or <em>remote_name</em> is null or <em>remote_name</em> is an absolute path. </dd></dl>

</div>
</div>
<a class="anchor" id="a10574c7cafdeaaef66a5962b63991920"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_buffer" ref="a10574c7cafdeaaef66a5962b63991920" args="(struct work_queue_task *t, const char *data, int length, const char *remote_name, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>remote_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an input <a class="el" href="structbuffer.html">buffer</a> to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The data to be passed as an input file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the <a class="el" href="structbuffer.html">buffer</a>, in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remote_name</em>&nbsp;</td><td>The name of the remote file to create. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>May be zero to indicate no special handling or any of the following or'd together:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a36066dcb0622e6a19a31da1c8a219d57">WORK_QUEUE_CACHE</a> indicates that the file should be cached for later tasks. (recommended)</li>
<li><a class="el" href="work__queue_8h.html#a5a4dc8d3ae3c734ea348c4e07bbe3451">WORK_QUEUE_NOCACHE</a> indicates that the file should not be cached for later tasks. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the task file is successfully specified, 0 if either of <em>t</em> or <em>remote_name</em> is null or <em>remote_name</em> is an absolute path. </dd></dl>

</div>
</div>
<a class="anchor" id="a243c871c96f08380b893e2ea63b0072d"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_directory" ref="a243c871c96f08380b893e2ea63b0072d" args="(struct work_queue_task *t, const char *local_name, const char *remote_name, int type, int flags, int recursive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_directory </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>local_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>remote_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>recursive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a directory to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local_name</em>&nbsp;</td><td>The name of the directory on local disk or shared filesystem. Optional if the directory is empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remote_name</em>&nbsp;</td><td>The name of the directory at the remote execution site. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Must be one of the following values:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#aec8d5ed52852a8dd772a6d6a362667af">WORK_QUEUE_INPUT</a> to indicate an input file to be consumed by the task</li>
<li><a class="el" href="work__queue_8h.html#ad62dbab142c500d243cebd796053ccf5">WORK_QUEUE_OUTPUT</a> to indicate an output file to be produced by the task </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>May be zero to indicate no special handling or any of the following or'd together:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a36066dcb0622e6a19a31da1c8a219d57">WORK_QUEUE_CACHE</a> indicates that the file should be cached for later tasks. (recommended)</li>
<li><a class="el" href="work__queue_8h.html#a5a4dc8d3ae3c734ea348c4e07bbe3451">WORK_QUEUE_NOCACHE</a> indicates that the file should not be cached for later tasks. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recursive</em>&nbsp;</td><td>indicates whether just the directory (0) or the directory and all of its contents (1) should be included. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the task directory is successfully specified, 0 if either of <em>t</em>, <em>local_name</em>, or <em>remote_name</em> is null or <em>remote_name</em> is an absolute path. </dd></dl>

</div>
</div>
<a class="anchor" id="a5203f51a095525a37d8b4c3428779a5a"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_memory" ref="a5203f51a095525a37d8b4c3428779a5a" args="(struct work_queue_task *t, int64_t memory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_memory </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>memory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the amount of memory required by a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memory</em>&nbsp;</td><td>The amount of memory required by the task, in megabytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade6a0fa5ed42d7b82f82c82336e748b0"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_disk" ref="ade6a0fa5ed42d7b82f82c82336e748b0" args="(struct work_queue_task *t, int64_t disk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_disk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>disk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the amount of disk space required by a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>disk</em>&nbsp;</td><td>The amount of disk space required by the task, in megabytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdd8963575b294e703b79c3655de426c"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_cores" ref="abdd8963575b294e703b79c3655de426c" args="(struct work_queue_task *t, int cores)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_cores </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cores</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the number of cores required by a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cores</em>&nbsp;</td><td>The number of cores required by the task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a572c831f87b142f96f764a640eef67"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_gpus" ref="a6a572c831f87b142f96f764a640eef67" args="(struct work_queue_task *t, int gpus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_gpus </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gpus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the number of gpus required by a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpus</em>&nbsp;</td><td>The number of gpus required by the task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e68c00abc2afe0a93649d67e863b848"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_tag" ref="a2e68c00abc2afe0a93649d67e863b848" args="(struct work_queue_task *t, const char *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_tag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach a user defined string tag to the task. </p>
<p>This field is not interpreted by the work queue, but is provided for the user's convenience in identifying tasks when they complete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag to attach to task t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7872d78c93ce446a29d5646164b61b66"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_algorithm" ref="a7872d78c93ce446a29d5646164b61b66" args="(struct work_queue_task *t, int algo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_specify_algorithm </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>algo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select the scheduling algorithm for a single task. </p>
<p>To change the scheduling algorithm for all tasks, use <a class="el" href="work__queue_8h.html#a2c25df729311b3ece2aeaf1a50bf72c6">work_queue_specify_algorithm</a> instead. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>algo</em>&nbsp;</td><td>The algorithm to use in assigning this task to a worker:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a1d1e09654125343a67426ee1f01e20b2">WORK_QUEUE_SCHEDULE_FCFS</a> - Select worker on a first-come-first-serve basis.</li>
<li><a class="el" href="work__queue_8h.html#ae25ae070d802ac0d66e00ef65b11c270">WORK_QUEUE_SCHEDULE_FILES</a> - Select worker that has the most data required by the task.</li>
<li><a class="el" href="work__queue_8h.html#a6e4eb36aa7ef72d9e52886824f918e16">WORK_QUEUE_SCHEDULE_TIME</a> - Select worker that has the fastest execution time on previous tasks.</li>
<li><a class="el" href="work__queue_8h.html#a7d079059081c4815b82f911ca4de2cdd">WORK_QUEUE_SCHEDULE_RAND</a> - Select a random worker. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabb0948d8e71e97ee786d636d8fca5ab"></a><!-- doxytag: member="work_queue.h::work_queue_task_delete" ref="aabb0948d8e71e97ee786d636d8fca5ab" args="(struct work_queue_task *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_task_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a task. </p>
<p>This may be called on tasks after they are returned from <a class="el" href="work__queue_8h.html#afd6ce91a68a5d68e423058bd876c98d2">work_queue_wait</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The task to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21714a10bcdfcf5c3bd44a96f5dcbda6"></a><!-- doxytag: member="work_queue.h::work_queue_create" ref="a21714a10bcdfcf5c3bd44a96f5dcbda6" args="(int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct work_queue* work_queue_create </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new work queue. </p>
<p>Users may modify the behavior of <a class="el" href="work__queue_8h.html#a21714a10bcdfcf5c3bd44a96f5dcbda6">work_queue_create</a> by setting the following environmental variables before calling the function:</p>
<ul>
<li><b>WORK_QUEUE_PORT</b>: This sets the default port of the queue (if unset, the default is 9123).</li>
<li><b>WORK_QUEUE_LOW_PORT</b>: If the user requests a random port, then this sets the first port number in the scan range (if unset, the default is 1024).</li>
<li><b>WORK_QUEUE_HIGH_PORT</b>: If the user requests a random port, then this sets the last port number in the scan range (if unset, the default is 32767).</li>
<li><b>WORK_QUEUE_NAME</b>: This sets the project name of the queue, which is reported to a catalog server (by default this is unset).</li>
<li><b>WORK_QUEUE_PRIORITY</b>: This sets the priority of the queue, which is used by workers to sort masters such that higher priority masters will be served first (if unset, the default is 10).</li>
</ul>
<p>If the queue has a project name, then queue statistics and information will be reported to a catalog server. To specify the catalog server, the user may set the <b>CATALOG_HOST</b> and <b>CATALOG_PORT</b> environmental variables as described in <a class="el" href="catalog__query_8h.html#ad75526413f4ee77ae6a1a829664ebae3">catalog_query_create</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number to listen on. If zero is specified, then the port stored in the <b>WORK_QUEUE_PORT</b> environment variable is used if available. If it isn't, or if -1 is specified, the first unused port between <b>WORK_QUEUE_LOW_PORT</b> and <b>WORK_QUEUE_HIGH_PORT</b> (1024 and 32767 by default) is chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new work queue, or null if it could not be created. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b0b3e49fc5c92d2c0c2c912f7d51807"></a><!-- doxytag: member="work_queue.h::work_queue_enable_monitoring" ref="a9b0b3e49fc5c92d2c0c2c912f7d51807" args="(struct work_queue *q, char *monitor_summary_file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_enable_monitoring </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>monitor_summary_file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables resource monitoring on the give work queue. </p>
<p>It generates the log file indicated by monitor_summary_file with all the summaries of the resources used by each task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>monitor_summary_file</em>&nbsp;</td><td>The filename of the log (If NULL, it defaults to wq-pid-resource-usage). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 if monitoring was not enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ac52e29cbe5c3137fdae20871156367df"></a><!-- doxytag: member="work_queue.h::work_queue_submit" ref="ac52e29cbe5c3137fdae20871156367df" args="(struct work_queue *q, struct work_queue_task *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_submit </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit a task to a queue. </p>
<p>Once a task is submitted to a queue, it is not longer under the user's control and should not be inspected until returned via <a class="el" href="work__queue_8h.html#afd6ce91a68a5d68e423058bd876c98d2">work_queue_wait</a>. Once returned, it is safe to re-submit the same take object via <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A task object returned from <a class="el" href="work__queue_8h.html#ad1343a34f7792d877bcc79a84bb436fd">work_queue_task_create</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An integer taskid assigned to the submitted task. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d31286dc2c8b5b1c8ac466116600501"></a><!-- doxytag: member="work_queue.h::work_queue_blacklist_add" ref="a8d31286dc2c8b5b1c8ac466116600501" args="(struct work_queue *q, const char *hostname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_blacklist_add </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blacklist host from a queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hostname</em>&nbsp;</td><td>A string for hostname. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab781f82af02fb0ba02e3a711644e847d"></a><!-- doxytag: member="work_queue.h::work_queue_blacklist_remove" ref="ab781f82af02fb0ba02e3a711644e847d" args="(struct work_queue *q, const char *hostname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_blacklist_remove </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unblacklist host from a queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hostname</em>&nbsp;</td><td>A string for hostname. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a188e3cf78af6059b069593df402f16f7"></a><!-- doxytag: member="work_queue.h::work_queue_blacklist_clear" ref="a188e3cf78af6059b069593df402f16f7" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_blacklist_clear </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear blacklist of a queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd6ce91a68a5d68e423058bd876c98d2"></a><!-- doxytag: member="work_queue.h::work_queue_wait" ref="afd6ce91a68a5d68e423058bd876c98d2" args="(struct work_queue *q, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a>* work_queue_wait </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a task to complete. </p>
<p>This call will block until either a task has completed, the timeout has expired, or the queue is empty. If a task has completed, the corresponding task object will be returned by this function. The caller may examine the task and then dispose of it using <a class="el" href="work__queue_8h.html#aabb0948d8e71e97ee786d636d8fca5ab">work_queue_task_delete</a>.</p>
<p>If the task ran to completion, then the <code>result</code> field will be zero and the <code>return_status</code> field will contain the Unix exit code of the task. If the task could not, then the <code>result</code> field will be non-zero and the <code>return_status</code> field will be undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The number of seconds to wait for a completed task before returning. Use an integer time to set the timeout or the constant <a class="el" href="work__queue_8h.html#a3cde1d463fec81eca0b4ced4fc1dc01e">WORK_QUEUE_WAITFORTASK</a> to block until a task has completed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A completed task description, or null if the queue is empty, or the timeout was reached without a completed task, or there is completed child process (call <a class="el" href="process_8h.html#a327770475af2930d6732a4d5244b3251">process_wait</a> to retrieve the status of the completed child process). </dd></dl>

</div>
</div>
<a class="anchor" id="afb70bbdb96e69717acd2d53554171d5c"></a><!-- doxytag: member="work_queue.h::work_queue_hungry" ref="afb70bbdb96e69717acd2d53554171d5c" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_hungry </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether the queue is 'hungry' for more tasks. </p>
<p>While the Work Queue can handle a very large number of tasks, it runs most efficiently when the number of tasks is slightly larger than the number of active workers. This function gives the user of a flexible application a hint about whether it would be better to submit more tasks via <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a> or wait for some to complete via <a class="el" href="work__queue_8h.html#afd6ce91a68a5d68e423058bd876c98d2">work_queue_wait</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of additional tasks that can be efficiently submitted, or zero if the queue has enough to work with right now. </dd></dl>

</div>
</div>
<a class="anchor" id="a825de0cbb8b3bf49b936d697d85e6157"></a><!-- doxytag: member="work_queue.h::work_queue_empty" ref="a825de0cbb8b3bf49b936d697d85e6157" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_empty </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine whether the queue is empty. </p>
<p>When all of the desired tasks have been submitted to the queue, the user should continue to call <a class="el" href="work__queue_8h.html#afd6ce91a68a5d68e423058bd876c98d2">work_queue_wait</a> until this function returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the queue is completely empty, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a087c13d03449c9746c3c73674a594e23"></a><!-- doxytag: member="work_queue.h::work_queue_port" ref="a087c13d03449c9746c3c73674a594e23" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_port </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the listening port of the queue. </p>
<p>As noted in <a class="el" href="work__queue_8h.html#a21714a10bcdfcf5c3bd44a96f5dcbda6">work_queue_create</a>, there are many controls that affect what TCP port the queue will listen on. Rather than assuming a specific port, the user should simply call this function to determine what port was selected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The port the queue is listening on. </dd></dl>

</div>
</div>
<a class="anchor" id="a8eb8088ee337106351c8646adc319de8"></a><!-- doxytag: member="work_queue.h::work_queue_get_stats" ref="a8eb8088ee337106351c8646adc319de8" args="(struct work_queue *q, struct work_queue_stats *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_get_stats </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__stats.html">work_queue_stats</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get queue statistics. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A pointer to a <a class="el" href="structbuffer.html">buffer</a> that will be filed with statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e423e16717e69b6ba9a268dee378a22"></a><!-- doxytag: member="work_queue.h::work_queue_set_bandwidth_limit" ref="a6e423e16717e69b6ba9a268dee378a22" args="(struct work_queue *q, const char *bandwidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_set_bandwidth_limit </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>bandwidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Limit the queue bandwidth when transferring files to and from workers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bandwidth</em>&nbsp;</td><td>The bandwidth limit in bytes per second. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a836f1cfa0e8b742f7c311e2664f7f6dd"></a><!-- doxytag: member="work_queue.h::work_queue_get_effective_bandwidth" ref="a836f1cfa0e8b742f7c311e2664f7f6dd" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double work_queue_get_effective_bandwidth </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current queue bandwidth. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The average bandwidth in MB/s measured by the master. </dd></dl>

</div>
</div>
<a class="anchor" id="a95bf1d7e3df002fde7cc09c88dd7737f"></a><!-- doxytag: member="work_queue.h::work_queue_get_worker_summary" ref="a95bf1d7e3df002fde7cc09c88dd7737f" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* work_queue_get_worker_summary </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Summarize workers. </p>
<p>This function summarizes the workers currently connected to the master, indicating how many from each worker pool are attached. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated string describing the distribution of workers by pool. The caller must release this string via free(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab14593aa7b1d2afbeef2c88799e02ba6"></a><!-- doxytag: member="work_queue.h::work_queue_activate_fast_abort" ref="ab14593aa7b1d2afbeef2c88799e02ba6" args="(struct work_queue *q, double multiplier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_activate_fast_abort </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>multiplier</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn on or off fast abort functionality for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiplier</em>&nbsp;</td><td>The multiplier of the average task time at which point to abort; if negative (and by default) fast_abort is deactivated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if activated or deactivated with an appropriate multiplier, 1 if deactivated due to inappropriate multiplier. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c25df729311b3ece2aeaf1a50bf72c6"></a><!-- doxytag: member="work_queue.h::work_queue_specify_algorithm" ref="a2c25df729311b3ece2aeaf1a50bf72c6" args="(struct work_queue *q, int algo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_algorithm </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>algo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the worker selection algorithm. </p>
<p>Note that this function controls which <b>worker</b> will be selected for a given task while <a class="el" href="work__queue_8h.html#af911446b986bfc87d0e88c826ab19475">work_queue_specify_task_order</a> controls which <b>task</b> will be executed next. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>algo</em>&nbsp;</td><td>The algorithm to use in assigning a task to a worker:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a1d1e09654125343a67426ee1f01e20b2">WORK_QUEUE_SCHEDULE_FCFS</a> - Select worker on a first-come-first-serve basis.</li>
<li><a class="el" href="work__queue_8h.html#ae25ae070d802ac0d66e00ef65b11c270">WORK_QUEUE_SCHEDULE_FILES</a> - Select worker that has the most data required by the task.</li>
<li><a class="el" href="work__queue_8h.html#a6e4eb36aa7ef72d9e52886824f918e16">WORK_QUEUE_SCHEDULE_TIME</a> - Select worker that has the fastest execution time on previous tasks.</li>
<li><a class="el" href="work__queue_8h.html#a7d079059081c4815b82f911ca4de2cdd">WORK_QUEUE_SCHEDULE_RAND</a> - Select a random worker. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af911446b986bfc87d0e88c826ab19475"></a><!-- doxytag: member="work_queue.h::work_queue_specify_task_order" ref="af911446b986bfc87d0e88c826ab19475" args="(struct work_queue *q, int order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_task_order </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>order</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify how the submitted tasks should be ordered. </p>
<p>Note that this function controls which <b>task</b> to execute next, while <a class="el" href="work__queue_8h.html#a2c25df729311b3ece2aeaf1a50bf72c6">work_queue_specify_algorithm</a> controls which <b>worker</b> it should be assigned to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>The ordering to use for dispatching submitted tasks:</p>
<ul>
<li><a class="el" href="work__queue_8h.html#a801aded6c67da94d5c9c85fd3dffdbc4">WORK_QUEUE_TASK_ORDER_LIFO</a></li>
<li><a class="el" href="work__queue_8h.html#ac00bd222bb7bb2b03017de2c25801ccd">WORK_QUEUE_TASK_ORDER_FIFO</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26ec8254fe6499ccf5c530bf8730c653"></a><!-- doxytag: member="work_queue.h::work_queue_name" ref="a26ec8254fe6499ccf5c530bf8730c653" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* work_queue_name </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the project name of the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The project name of the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6f846a7966797554670c869a2a3a9b"></a><!-- doxytag: member="work_queue.h::work_queue_specify_name" ref="a1a6f846a7966797554670c869a2a3a9b" args="(struct work_queue *q, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_name </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the project name for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The new project name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62e07e64203ac185279fae6b6952de11"></a><!-- doxytag: member="work_queue.h::work_queue_specify_priority" ref="a62e07e64203ac185279fae6b6952de11" args="(struct work_queue *q, int priority)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_priority </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>priority</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the priority for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>The new priority of the queue. Higher priority masters will attract workers first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7291e2c8fe58f79364111428636286b"></a><!-- doxytag: member="work_queue.h::work_queue_specify_catalog_server" ref="aa7291e2c8fe58f79364111428636286b" args="(struct work_queue *q, const char *hostname, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_catalog_server </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the catalog server the master should report to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hostname</em>&nbsp;</td><td>The catalog server's hostname. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port the catalog server is listening on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac94746fc9c8206f8f003878e40e9030b"></a><!-- doxytag: member="work_queue.h::work_queue_cancel_by_taskid" ref="ac94746fc9c8206f8f003878e40e9030b" args="(struct work_queue *q, int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a>* work_queue_cancel_by_taskid </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel a submitted task using its task id and remove it from queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The taskid returned from <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The task description of the cancelled task, or null if the task was not found in queue. The returned task must be deleted with <a class="el" href="work__queue_8h.html#aabb0948d8e71e97ee786d636d8fca5ab">work_queue_task_delete</a> or resubmitted with <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4998d3840cfd83cdbfc522d4870464f"></a><!-- doxytag: member="work_queue.h::work_queue_cancel_by_tasktag" ref="ae4998d3840cfd83cdbfc522d4870464f" args="(struct work_queue *q, const char *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a>* work_queue_cancel_by_tasktag </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel a submitted task using its tag and remove it from queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag name assigned to task using <a class="el" href="work__queue_8h.html#a2e68c00abc2afe0a93649d67e863b848">work_queue_task_specify_tag</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The task description of the cancelled task, or null if the task was not found in queue. The returned task must be deleted with <a class="el" href="work__queue_8h.html#aabb0948d8e71e97ee786d636d8fca5ab">work_queue_task_delete</a> or resubmitted with <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aab4002baf71625fc68f4507dee61f0b0"></a><!-- doxytag: member="work_queue.h::work_queue_cancel_all_tasks" ref="aab4002baf71625fc68f4507dee61f0b0" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structlist.html">list</a>* work_queue_cancel_all_tasks </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel all submitted tasks and remove them from the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="structlist.html">list</a> of all of the tasks submitted to q. Each task must be deleted with <a class="el" href="work__queue_8h.html#aabb0948d8e71e97ee786d636d8fca5ab">work_queue_task_delete</a> or resubmitted with <a class="el" href="work__queue_8h.html#ac52e29cbe5c3137fdae20871156367df">work_queue_submit</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8a7df762311589c0e9c91b13f6d4e80"></a><!-- doxytag: member="work_queue.h::work_queue_shut_down_workers" ref="ac8a7df762311589c0e9c91b13f6d4e80" args="(struct work_queue *q, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_shut_down_workers </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shut down workers connected to the work_queue system. </p>
<p>Gives a best effort and then returns the number of workers given the shut down order. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number to shut down. All workers if given "0". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a292be23ed3988cc9e92389f8356b6b"></a><!-- doxytag: member="work_queue.h::work_queue_delete" ref="a4a292be23ed3988cc9e92389f8356b6b" args="(struct work_queue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_delete </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a work queue. </p>
<p>This function should only be called after <a class="el" href="work__queue_8h.html#a825de0cbb8b3bf49b936d697d85e6157">work_queue_empty</a> returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9159948b43e9ec25e4b21cc985562eea"></a><!-- doxytag: member="work_queue.h::work_queue_specify_log" ref="a9159948b43e9ec25e4b21cc985562eea" args="(struct work_queue *q, const char *logfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_specify_log </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>logfile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a log file that records the states of the connected workers and submitted tasks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>logfile</em>&nbsp;</td><td>The filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if logfile was opened, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a43027dbf0cc845a9a62eda7829f19ba4"></a><!-- doxytag: member="work_queue.h::work_queue_specify_password" ref="a43027dbf0cc845a9a62eda7829f19ba4" args="(struct work_queue *q, const char *password)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_password </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>password</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a mandatory password that each worker must present. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>password</em>&nbsp;</td><td>The password to require. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1d9f0f8bb84829a43a2c404c57a213b"></a><!-- doxytag: member="work_queue.h::work_queue_specify_password_file" ref="af1d9f0f8bb84829a43a2c404c57a213b" args="(struct work_queue *q, const char *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_specify_password_file </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a mandatory password file that each worker must present. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The name of the file containing the password. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the password was loaded, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f46688fe5c9d5c09ada61620cf1a309"></a><!-- doxytag: member="work_queue.h::work_queue_specify_keepalive_interval" ref="a3f46688fe5c9d5c09ada61620cf1a309" args="(struct work_queue *q, int interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_keepalive_interval </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the keepalive interval for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td>The minimum number of seconds to wait before sending new keepalive checks to workers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f9be386cae7b3282a4060361b8a7efb"></a><!-- doxytag: member="work_queue.h::work_queue_specify_keepalive_timeout" ref="a2f9be386cae7b3282a4060361b8a7efb" args="(struct work_queue *q, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_keepalive_timeout </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the keepalive timeout for identifying dead workers for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The minimum number of seconds to wait for a keepalive response from worker before marking it as dead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a493c353e1aca544f43b1cda35a80eea0"></a><!-- doxytag: member="work_queue.h::work_queue_tune" ref="a493c353e1aca544f43b1cda35a80eea0" args="(struct work_queue *q, const char *name, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_tune </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tune advanced parameters for work queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the parameter to tune</p>
<ul>
<li>"asynchrony-multiplier" Treat each worker as having (actual_cores * multiplier) total cores. (default = 1.0)</li>
<li>"asynchrony-modifier" Treat each worker as having an additional "modifier" cores. (default=0)</li>
<li>"min-transfer-timeout" Set the minimum number of seconds to wait for files to be transferred to or from a worker. (default=10)</li>
<li>"foreman-transfer-timeout" Set the minimum number of seconds to wait for files to be transferred to or from a foreman. (default=3600)</li>
<li>"transfer-outlier-factor" Transfer that are this many times slower than the average will be aborted. (default=10x)</li>
<li>"default-transfer-rate" The assumed network bandwidth used until sufficient data has been collected. (1MB/s)</li>
<li>"fast-abort-multiplier" Set the multiplier of the average task time at which point to abort; if negative or zero fast_abort is deactivated. (default=0)</li>
<li>"keepalive-interval" Set the minimum number of seconds to wait before sending new keepalive checks to workers. (default=300)</li>
<li>"keepalive-timeout" Set the minimum number of seconds to wait for a keepalive response from worker before marking it as dead. (default=30) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set the parameter to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on succes, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a36592ac2e2959acb7d6976bc96d6d707"></a><!-- doxytag: member="work_queue.h::work_queue_specify_master_mode" ref="a36592ac2e2959acb7d6976bc96d6d707" args="(struct work_queue *q, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_master_mode </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify the master mode for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td><ul>
<li><a class="el" href="work__queue_8h.html#a4c83ef0763b818c5479ae652a1476798">WORK_QUEUE_MASTER_MODE_STANDALONE</a> - standalone mode. In this mode the master would not report its information to a catalog server;</li>
<li><a class="el" href="work__queue_8h.html#a763c12b05763df694f7519a8fd56c35d">WORK_QUEUE_MASTER_MODE_CATALOG</a> - catalog mode. In this mode the master report itself to a catalog server where workers get masters' information and select a master to serve. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Enabled automatically when <a class="el" href="work__queue_8h.html#a1a6f846a7966797554670c869a2a3a9b">work_queue_specify_name</a> is used. </dd></dl>

</div>
</div>
<a class="anchor" id="a26ecb96db8972ec708f896d0f7d53807"></a><!-- doxytag: member="work_queue.h::work_queue_specify_estimate_capacity_on" ref="a26ecb96db8972ec708f896d0f7d53807" args="(struct work_queue *q, int estimate_capacity_on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void work_queue_specify_estimate_capacity_on </td>
          <td>(</td>
          <td class="paramtype">struct work_queue *&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>estimate_capacity_on</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change whether to estimate master capacity for a given queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A work queue object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>estimate_capacity_on</em>&nbsp;</td><td>if the value of this parameter is 1, then work queue should estimate the master capacity. If the value is 0, then work queue would not estimate its master capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This feature is always enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2b5e1955e01a4d17c6d8cf9d54870e7"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_input_buf" ref="ae2b5e1955e01a4d17c6d8cf9d54870e7" args="(struct work_queue_task *t, const char *buf, int length, const char *rname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_input_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an input <a class="el" href="structbuffer.html">buffer</a> to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The task to which to add parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A pointer to the data <a class="el" href="structbuffer.html">buffer</a> to send to the worker to be available to the commands. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes of data in the <a class="el" href="structbuffer.html">buffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rname</em>&nbsp;</td><td>The name of the file in which to store the <a class="el" href="structbuffer.html">buffer</a> data on the worker </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the input <a class="el" href="structbuffer.html">buffer</a> is successfully specified, 0 if either of <em>t</em> or <em>rname</em> is null or <em>rname</em> is an absolute path. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use <a class="el" href="work__queue_8h.html#a10574c7cafdeaaef66a5962b63991920">work_queue_task_specify_buffer</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b4f1fb3167f8d754f435462b09e334e"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_input_file" ref="a2b4f1fb3167f8d754f435462b09e334e" args="(struct work_queue_task *t, const char *fname, const char *rname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_input_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an input file to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The task to which to add parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fname</em>&nbsp;</td><td>The name of the data file to send to the worker to be available to the commands. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rname</em>&nbsp;</td><td>The name of the file in which to store the <a class="el" href="structbuffer.html">buffer</a> data on the worker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the input file is successfully specified, 0 if either of <em>t</em>, <em>fname</em>, or <em>rname</em> is null or <em>rname</em> is an absolute path. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>See <a class="el" href="work__queue_8h.html#a3070da55a7fe72f8cab43f81cdc07df4">work_queue_task_specify_file</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9b4aed8e4d44f1f0788db3c7c523065"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_input_file_do_not_cache" ref="aa9b4aed8e4d44f1f0788db3c7c523065" args="(struct work_queue_task *t, const char *fname, const char *rname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_input_file_do_not_cache </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an input file to a task, without caching. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The task to which to add parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fname</em>&nbsp;</td><td>The name of the data file to send to the worker to be available to the commands. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rname</em>&nbsp;</td><td>The name of the file in which to store the <a class="el" href="structbuffer.html">buffer</a> data on the worker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the input file is successfully specified, 0 if either of <em>t</em>, <em>fname</em>, or <em>rname</em> is null or <em>rname</em> is an absolute path. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>See <a class="el" href="work__queue_8h.html#a3070da55a7fe72f8cab43f81cdc07df4">work_queue_task_specify_file</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e896ccd2e2fb6c95f9e3f32ed52348d"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_output_file" ref="a8e896ccd2e2fb6c95f9e3f32ed52348d" args="(struct work_queue_task *t, const char *rname, const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_output_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an output file to a task. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The task to which to add parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rname</em>&nbsp;</td><td>The name of a file created by the program when it runs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fname</em>&nbsp;</td><td>The name of the file local target for copying rname back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the output file is successfully specified, 0 if either of <em>t</em>, <em>fname</em>, or <em>rname</em> is null or <em>rname</em> is an absolute path. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>See <a class="el" href="work__queue_8h.html#a3070da55a7fe72f8cab43f81cdc07df4">work_queue_task_specify_file</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="acf60cabad0fa573953a782cf6e4676f5"></a><!-- doxytag: member="work_queue.h::work_queue_task_specify_output_file_do_not_cache" ref="acf60cabad0fa573953a782cf6e4676f5" args="(struct work_queue_task *t, const char *rname, const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int work_queue_task_specify_output_file_do_not_cache </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwork__queue__task.html">work_queue_task</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an output file to a task without caching. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The task to which to add parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rname</em>&nbsp;</td><td>The name of a file created by the program when it runs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fname</em>&nbsp;</td><td>The name of the file local target for copying rname back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the output file is successfully specified, 0 if either of <em>t</em>, <em>fname</em>, or <em>rname</em> is null or <em>rname</em> is an absolute path. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>See <a class="el" href="work__queue_8h.html#a3070da55a7fe72f8cab43f81cdc07df4">work_queue_task_specify_file</a> instead. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a347c0916bec6201436bb7618b5a46d0c"></a><!-- doxytag: member="work_queue.h::wq_option_fast_abort_multiplier" ref="a347c0916bec6201436bb7618b5a46d0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="work__queue_8h.html#a347c0916bec6201436bb7618b5a46d0c">wq_option_fast_abort_multiplier</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initial setting for fast abort multiplier upon creating queue. </p>
<p>Turned off if less than 0. Change prior to calling work_queue_create, after queue is created this variable is not considered and changes must be made through the API calls. </p>

</div>
</div>
<a class="anchor" id="a564c89add39f633ca105efd223d44846"></a><!-- doxytag: member="work_queue.h::wq_option_scheduler" ref="a564c89add39f633ca105efd223d44846" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="work__queue_8h.html#a564c89add39f633ca105efd223d44846">wq_option_scheduler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initial setting for algorithm to assign tasks to workers upon creating queue . </p>
<p>Change prior to calling work_queue_create, after queue is created this variable is not considered and changes must be made through the API calls. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 10 Jul 2014 for cctools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
