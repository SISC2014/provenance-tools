<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cctools: link.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_e91b50daf043faf49e177c41e4045673.html">dttools</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_6799dea93b790a5bddb17668b32e0132.html">src</a>
  </div>
</div>
<div class="contents">
<h1>link.h File Reference</h1>
<p>A high level TCP connection library.  
<a href="#_details">More...</a></p>
<code>#include &quot;int_sizes.h&quot;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;signal.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>

<p><a href="link_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlink__info.html">link_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activity structure passed to <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a>.  <a href="structlink__info.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#aee1eac35b3b0cc6899cdc3ee0af78f4e">LINK_ADDRESS_MAX</a>&nbsp;&nbsp;&nbsp;48</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of characters in the text representation of a link address.  <a href="#aee1eac35b3b0cc6899cdc3ee0af78f4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#aa76c893b5d09fa568b93572e96e14f12">LINK_PORT_ANY</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value to usewhen any listen port is acceptable.  <a href="#aa76c893b5d09fa568b93572e96e14f12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#ae45ac49c99cde97c10671966d8ea1ecb">LINK_FOREVER</a>&nbsp;&nbsp;&nbsp;((time_t)INT_MAX)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stoptime to give when you wish to wait forever.  <a href="#ae45ac49c99cde97c10671966d8ea1ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a0d5ec33b12de7dda233ea05bbacc7c65">LINK_READ</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates a link is ready to read via <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a>.  <a href="#a0d5ec33b12de7dda233ea05bbacc7c65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#af4b78ceac793977641f745a92d98a6fa">LINK_WRITE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates a link is ready to write via <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a>.  <a href="#af4b78ceac793977641f745a92d98a6fa"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3">link_tune_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3aca07a3aeb6ab870e21c4ad322c11329c">LINK_TUNE_INTERACTIVE</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3ab0b1f1df5c3a5e1bc4da27498d3bcf83">LINK_TUNE_BULK</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Options for link performance tuning. </p>
 <a href="link_8h.html#a0c250676329168686ded80c4f738e7d3">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a320c480103b59a4048d22cdc5329004c">link_connect</a> (const char *addr, int port, time_t stoptime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a remote host.  <a href="#a320c480103b59a4048d22cdc5329004c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#adbd1b2e5e35ab68988604ef3e823c500">link_attach_to_file</a> (FILE *file)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn a FILE* into a link.  <a href="#adbd1b2e5e35ab68988604ef3e823c500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a8e12f4c41eec5eda31ac94e54ec1ee67">link_attach_to_fd</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn an fd into a link.  <a href="#a8e12f4c41eec5eda31ac94e54ec1ee67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a9d76a3da9666eb0788ee1a5887d0627d">link_serve</a> (int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare to accept connections.  <a href="#a9d76a3da9666eb0788ee1a5887d0627d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a7824b35abbe693a24f25f40085c17239">link_serve_range</a> (int low, int high)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare to accept connections.  <a href="#a7824b35abbe693a24f25f40085c17239"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#acd32b7ea948942d215442cc21ed04565">link_serve_address</a> (const char *addr, int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare to accept connections on one network interface.  <a href="#acd32b7ea948942d215442cc21ed04565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a4f6bd6784da481200baa6de29b75d2ba">link_serve_addrrange</a> (const char *addr, int low, int high)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare to accept connections on one network interface.  <a href="#a4f6bd6784da481200baa6de29b75d2ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a8908af96a78489539f87f902b6f81500">link_accept</a> (struct link *master, time_t stoptime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept one connection.  <a href="#a8908af96a78489539f87f902b6f81500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#afa7ddc80ab1ca813ad9f0ec7a6b92174">link_read</a> (struct link *link, char *data, size_t length, time_t stoptime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a connection.  <a href="#afa7ddc80ab1ca813ad9f0ec7a6b92174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#aa2435e70ed4e9ed10edb5f39a4c22dee">link_read_avail</a> (struct link *link, char *data, size_t length, time_t stoptime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read available data from a connection.  <a href="#aa2435e70ed4e9ed10edb5f39a4c22dee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#abad0017bf959aad067400ba9cbfbe4a2">link_write</a> (struct link *link, const char *data, size_t length, time_t stoptime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to a connection.  <a href="#abad0017bf959aad067400ba9cbfbe4a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a070a0ba62ec524026cbcccfe4a8d2227">link_putfstring</a> (struct link *link, const char *fmt, time_t stoptime,...) __attribute__((format(printf</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write formatted data to a connection.  <a href="#a070a0ba62ec524026cbcccfe4a8d2227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a467310e10118be95575d92f4aa313663">link_putvfstring</a> (struct link *link, const char *fmt, time_t stoptime, va_list va)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write formatted data to a connection.  <a href="#a467310e10118be95575d92f4aa313663"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a88872a9b3d0490d2f690e34486786ac5">link_usleep</a> (struct link *link, int usec, int reading, int writing)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block until a link is readable or writable.  <a href="#a88872a9b3d0490d2f690e34486786ac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a739c1a473985ff7af6965c8b698b18ca">link_sleep</a> (struct link *link, time_t stoptime, int reading, int writing)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block until a link is readable or writable.  <a href="#a739c1a473985ff7af6965c8b698b18ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a78703bd2617ee9ad8241a827d073845a">link_close</a> (struct link *link)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a connection.  <a href="#a78703bd2617ee9ad8241a827d073845a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a9f361d868559ff395ca2d8bad177e511">link_detach</a> (struct link *link)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach a link from the underlying file descriptor.  <a href="#a9f361d868559ff395ca2d8bad177e511"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a7045ffa5914a397e65ff2fe6383cf5fa">link_window_set</a> (int send_window, int recv_window)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the TCP window size to be used for all links.  <a href="#a7045ffa5914a397e65ff2fe6383cf5fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a7037bdee21acda4661afa54614fc917b">link_window_get</a> (struct link *link, int *send_window, int *recv_window)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the TCP window size actually allocated for this link.  <a href="#a7037bdee21acda4661afa54614fc917b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a3445c1f9cf4740c65b693e9f49f40432">link_readline</a> (struct link *link, char *line, size_t length, time_t stoptime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a line of text from a link.  <a href="#a3445c1f9cf4740c65b693e9f49f40432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a97dac33660a5fb7333807bb90812a641">link_fd</a> (struct link *link)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying file descriptor of a link.  <a href="#a97dac33660a5fb7333807bb90812a641"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a621e6102436eeca74c1bd46b0c680873">link_buffer_empty</a> (struct link *link)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether a link has unread contents in its <a class="el" href="structbuffer.html">buffer</a>.  <a href="#a621e6102436eeca74c1bd46b0c680873"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#acc347b042e023a279eec60de1395e9ae">link_address_local</a> (struct link *link, char *addr, int *port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the local address of the link in text format.  <a href="#acc347b042e023a279eec60de1395e9ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#ab692af1dacd63beb4d333fb8b5d117dc">link_address_remote</a> (struct link *link, char *addr, int *port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the remote address of the link in text format.  <a href="#ab692af1dacd63beb4d333fb8b5d117dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a40884871d97e2b9bd6bac5b62a1ca217">link_tune</a> (struct link *link, <a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3">link_tune_t</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tune a link for interactive or bulk performance.  <a href="#a40884871d97e2b9bd6bac5b62a1ca217"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a> (struct <a class="el" href="structlink__info.html">link_info</a> *array, int nlinks, int msec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a activity on a an array of links.  <a href="#a2130f3c33a717a38fb0a0ca143e9ed85"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A high level TCP connection library. </p>
<p>A <b>link</b> is a TCP connection to a process on another machine. This module works at a higher level of abstraction than the socket library, with an easier-to-use API and explicit support for timeouts. </p>
<p>Timeouts are specified using an absolute stoptime. For example, if you want a connection to be attempted for sixty seconds, specify <code>time(0)+60</code>. The operation will be tried and retried until that absolute limit, giving the caller much greater control over program behavior. </p>
<p>Note that this library manipulates IP addresses in the form of strings. To convert a hostname into a string IP address, call <a class="el" href="domain__name__cache_8h.html#a4bcc4c869a2836fe2295d758391e6d09">domain_name_cache_lookup</a>. For example, here is how to make a simple HTTP request: </p>
<pre>
struct link *link;
time_t stoptime = time(0)+300;
char addr[LINK_ADDRESS_MAX];
int result;</pre><pre>const char *request = "GET / HTTP/1.0\n\n";</pre><pre>result = domain_name_cache_lookup("www.google.com",addr);
if(!result) fatal("could not lookup name");</pre><pre>link = link_connect(addr,80,stoptime);
if(!link) fatal("could not connect");</pre><pre>result = link_write(link,request,strlen(request),stoptime);
if(result&lt;0) fatal("could not send request");</pre><pre>link_stream_to_file(link,stdout,1000000,stoptime);
link_close(link);
</pre> <hr/><h2>Define Documentation</h2>
<a class="anchor" id="aee1eac35b3b0cc6899cdc3ee0af78f4e"></a><!-- doxytag: member="link.h::LINK_ADDRESS_MAX" ref="aee1eac35b3b0cc6899cdc3ee0af78f4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_ADDRESS_MAX&nbsp;&nbsp;&nbsp;48</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum number of characters in the text representation of a link address. </p>
<p>This must be large enough to accomodate ipv6 in the future. </p>

</div>
</div>
<a class="anchor" id="aa76c893b5d09fa568b93572e96e14f12"></a><!-- doxytag: member="link.h::LINK_PORT_ANY" ref="aa76c893b5d09fa568b93572e96e14f12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_PORT_ANY&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value to usewhen any listen port is acceptable. </p>

</div>
</div>
<a class="anchor" id="ae45ac49c99cde97c10671966d8ea1ecb"></a><!-- doxytag: member="link.h::LINK_FOREVER" ref="ae45ac49c99cde97c10671966d8ea1ecb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_FOREVER&nbsp;&nbsp;&nbsp;((time_t)INT_MAX)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stoptime to give when you wish to wait forever. </p>

</div>
</div>
<a class="anchor" id="a0d5ec33b12de7dda233ea05bbacc7c65"></a><!-- doxytag: member="link.h::LINK_READ" ref="a0d5ec33b12de7dda233ea05bbacc7c65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_READ&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates a link is ready to read via <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a>. </p>

</div>
</div>
<a class="anchor" id="af4b78ceac793977641f745a92d98a6fa"></a><!-- doxytag: member="link.h::LINK_WRITE" ref="af4b78ceac793977641f745a92d98a6fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_WRITE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates a link is ready to write via <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a>. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a0c250676329168686ded80c4f738e7d3"></a><!-- doxytag: member="link.h::link_tune_t" ref="a0c250676329168686ded80c4f738e7d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3">link_tune_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Options for link performance tuning. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0c250676329168686ded80c4f738e7d3aca07a3aeb6ab870e21c4ad322c11329c"></a><!-- doxytag: member="LINK_TUNE_INTERACTIVE" ref="a0c250676329168686ded80c4f738e7d3aca07a3aeb6ab870e21c4ad322c11329c" args="" -->LINK_TUNE_INTERACTIVE</em>&nbsp;</td><td>
<p>Data is sent immediately to optimze interactive latency. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0c250676329168686ded80c4f738e7d3ab0b1f1df5c3a5e1bc4da27498d3bcf83"></a><!-- doxytag: member="LINK_TUNE_BULK" ref="a0c250676329168686ded80c4f738e7d3ab0b1f1df5c3a5e1bc4da27498d3bcf83" args="" -->LINK_TUNE_BULK</em>&nbsp;</td><td>
<p>Data may be buffered to improve throughput of large transfers. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a320c480103b59a4048d22cdc5329004c"></a><!-- doxytag: member="link.h::link_connect" ref="a320c480103b59a4048d22cdc5329004c" args="(const char *addr, int port, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to a remote host. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of server in string form. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port of server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>Absolute time at which to abort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, returns a pointer to a link object. On failure, returns a null pointer with errno set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="adbd1b2e5e35ab68988604ef3e823c500"></a><!-- doxytag: member="link.h::link_attach_to_file" ref="adbd1b2e5e35ab68988604ef3e823c500" args="(FILE *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_attach_to_file </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn a FILE* into a link. </p>
<p>Useful when trying to poll both remote and local connections using <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>File to create the link from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, returns a pointer to a link object. On failure, returns a null pointer with errno set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e12f4c41eec5eda31ac94e54ec1ee67"></a><!-- doxytag: member="link.h::link_attach_to_fd" ref="a8e12f4c41eec5eda31ac94e54ec1ee67" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_attach_to_fd </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn an fd into a link. </p>
<p>Useful when trying to poll both remote and local connections using <a class="el" href="link_8h.html#a2130f3c33a717a38fb0a0ca143e9ed85">link_poll</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>File descriptor to create the link from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, returns a pointer to a link object. On failure, returns a null pointer with errno set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d76a3da9666eb0788ee1a5887d0627d"></a><!-- doxytag: member="link.h::link_serve" ref="a9d76a3da9666eb0788ee1a5887d0627d" args="(int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_serve </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare to accept connections. </p>
<p><a class="el" href="link_8h.html#a9d76a3da9666eb0788ee1a5887d0627d">link_serve</a> will accept connections on any network interface, which is usually what you want. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number to listen on. If less than 1, the first unused port between TCP_LOW_PORT and TCP_HIGH_PORT will be selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>link A server endpoint that can be passed to <a class="el" href="link_8h.html#a8908af96a78489539f87f902b6f81500">link_accept</a>, or null on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7824b35abbe693a24f25f40085c17239"></a><!-- doxytag: member="link.h::link_serve_range" ref="a7824b35abbe693a24f25f40085c17239" args="(int low, int high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_serve_range </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>high</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare to accept connections. </p>
<p><a class="el" href="link_8h.html#a7824b35abbe693a24f25f40085c17239">link_serve_range</a> will accept connections on any network interface, which is usually what you want. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>low</em>&nbsp;</td><td>The low port in a range to listen on (inclusive). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>high</em>&nbsp;</td><td>The high port in a range to listen on (inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>link A server endpoint that can be passed to <a class="el" href="link_8h.html#a8908af96a78489539f87f902b6f81500">link_accept</a>, or null on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="acd32b7ea948942d215442cc21ed04565"></a><!-- doxytag: member="link.h::link_serve_address" ref="acd32b7ea948942d215442cc21ed04565" args="(const char *addr, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_serve_address </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare to accept connections on one network interface. </p>
<p>Functions like <a class="el" href="link_8h.html#a9d76a3da9666eb0788ee1a5887d0627d">link_serve</a>, except that the server will only be visible on the given network interface. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of the network interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number to listen on. If less than 1, the first unused port between TCP_LOW_PORT and TCP_HIGH_PORT will be selected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>link A server endpoint that can be passed to <a class="el" href="link_8h.html#a8908af96a78489539f87f902b6f81500">link_accept</a>, or null on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f6bd6784da481200baa6de29b75d2ba"></a><!-- doxytag: member="link.h::link_serve_addrrange" ref="a4f6bd6784da481200baa6de29b75d2ba" args="(const char *addr, int low, int high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_serve_addrrange </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>high</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare to accept connections on one network interface. </p>
<p>Functions like <a class="el" href="link_8h.html#a9d76a3da9666eb0788ee1a5887d0627d">link_serve</a>, except that the server will only be visible on the given network interface and allows for a port range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of the network interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low</em>&nbsp;</td><td>The low port in a range to listen on (inclusive). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>high</em>&nbsp;</td><td>The high port in a range to listen on (inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>link A server endpoint that can be passed to <a class="el" href="link_8h.html#a8908af96a78489539f87f902b6f81500">link_accept</a>, or null on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a8908af96a78489539f87f902b6f81500"></a><!-- doxytag: member="link.h::link_accept" ref="a8908af96a78489539f87f902b6f81500" args="(struct link *master, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_accept </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept one connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>master</em>&nbsp;</td><td>A link returned from <a class="el" href="link_8h.html#a9d76a3da9666eb0788ee1a5887d0627d">link_serve</a> or <a class="el" href="link_8h.html#acd32b7ea948942d215442cc21ed04565">link_serve_address</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>link A connection to a client, or null on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="afa7ddc80ab1ca813ad9f0ec7a6b92174"></a><!-- doxytag: member="link.h::link_read" ref="afa7ddc80ab1ca813ad9f0ec7a6b92174" args="(struct link *link, char *data, size_t length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_read </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from a connection. </p>
<p>This call will block until the given number of bytes have been read, or the connection is dropped. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link from which to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A <a class="el" href="structbuffer.html">buffer</a> to hold the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually read, or zero if the connection is closed, or less than zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2435e70ed4e9ed10edb5f39a4c22dee"></a><!-- doxytag: member="link.h::link_read_avail" ref="aa2435e70ed4e9ed10edb5f39a4c22dee" args="(struct link *link, char *data, size_t length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_read_avail </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read available data from a connection. </p>
<p>This call will read whatever data is immediately available, and then return without blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link from which to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A <a class="el" href="structbuffer.html">buffer</a> to hold the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually read, or zero if the connection is closed, or less than zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="abad0017bf959aad067400ba9cbfbe4a2"></a><!-- doxytag: member="link.h::link_write" ref="abad0017bf959aad067400ba9cbfbe4a2" args="(struct link *link, const char *data, size_t length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_write </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to a connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, or less than zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a070a0ba62ec524026cbcccfe4a8d2227"></a><!-- doxytag: member="link.h::link_putfstring" ref="a070a0ba62ec524026cbcccfe4a8d2227" args="(struct link *link, const char *fmt, time_t stoptime,...) __attribute__((format(printf" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_putfstring </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write formatted data to a connection. </p>
<p>All data is written until finished or an error is encountered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>A pointer to the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>Format arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, or less than zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a467310e10118be95575d92f4aa313663"></a><!-- doxytag: member="link.h::link_putvfstring" ref="a467310e10118be95575d92f4aa313663" args="(struct link *link, const char *fmt, time_t stoptime, va_list va)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int int link_putvfstring </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>va</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write formatted data to a connection. </p>
<p>All data is written until finished or an error is encountered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>A pointer to the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>va</em>&nbsp;</td><td>Format arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written, or less than zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a88872a9b3d0490d2f690e34486786ac5"></a><!-- doxytag: member="link.h::link_usleep" ref="a88872a9b3d0490d2f690e34486786ac5" args="(struct link *link, int usec, int reading, int writing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_usleep </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>writing</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block until a link is readable or writable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usec</em>&nbsp;</td><td>The maximum number of microseconds to wait. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reading</em>&nbsp;</td><td>Wait for the link to become readable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writing</em>&nbsp;</td><td>Wait for the link to become writable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One if the link becomes readable or writable before the timeout expires, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a739c1a473985ff7af6965c8b698b18ca"></a><!-- doxytag: member="link.h::link_sleep" ref="a739c1a473985ff7af6965c8b698b18ca" args="(struct link *link, time_t stoptime, int reading, int writing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_sleep </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>writing</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block until a link is readable or writable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reading</em>&nbsp;</td><td>Wait for the link to become readable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writing</em>&nbsp;</td><td>Wait for the link to become writable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One if the link becomes readable or writable before the timeout expires, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a78703bd2617ee9ad8241a827d073845a"></a><!-- doxytag: member="link.h::link_close" ref="a78703bd2617ee9ad8241a827d073845a" args="(struct link *link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_close </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The connection to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f361d868559ff395ca2d8bad177e511"></a><!-- doxytag: member="link.h::link_detach" ref="a9f361d868559ff395ca2d8bad177e511" args="(struct link *link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_detach </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach a link from the underlying file descriptor. </p>
<p>Deletes the link structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to detach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7045ffa5914a397e65ff2fe6383cf5fa"></a><!-- doxytag: member="link.h::link_window_set" ref="a7045ffa5914a397e65ff2fe6383cf5fa" args="(int send_window, int recv_window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_window_set </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>send_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>recv_window</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the TCP window size to be used for all links. </p>
<p>Takes effect on future calls to <a class="el" href="link_8h.html#a320c480103b59a4048d22cdc5329004c">link_connect</a> or <a class="el" href="link_8h.html#a8908af96a78489539f87f902b6f81500">link_accept</a>. Default value is set by the system or by the environment variable TCP_WINDOW_SIZE. Note that the operating system may place limits on the <a class="el" href="structbuffer.html">buffer</a> sizes actually allocated. Use <a class="el" href="link_8h.html#a7037bdee21acda4661afa54614fc917b">link_window_get</a> to retrieve the <a class="el" href="structbuffer.html">buffer</a> actually allocated for a given link. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>send_window</em>&nbsp;</td><td>The size of the send window, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv_window</em>&nbsp;</td><td>The size of the recv window, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7037bdee21acda4661afa54614fc917b"></a><!-- doxytag: member="link.h::link_window_get" ref="a7037bdee21acda4661afa54614fc917b" args="(struct link *link, int *send_window, int *recv_window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_window_get </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>send_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>recv_window</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the TCP window size actually allocated for this link. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>send_window</em>&nbsp;</td><td>A pointer where to store the send window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv_window</em>&nbsp;</td><td>A pointer where to store the receive window. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3445c1f9cf4740c65b693e9f49f40432"></a><!-- doxytag: member="link.h::link_readline" ref="a3445c1f9cf4740c65b693e9f49f40432" args="(struct link *link, char *line, size_t length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_readline </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a line of text from a link. </p>
<p>Reads a line of text, up to and including a newline, interpreted as either LF or CR followed by LF. The line actually returned is null terminated and does not contain the newline indicator. An internal <a class="el" href="structbuffer.html">buffer</a> is used so that readline can usually complete with zero or one system calls. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>A pointer to a <a class="el" href="structbuffer.html">buffer</a> to fill with data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the <a class="el" href="structbuffer.html">buffer</a> in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The absolute time at which to abort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If greater than zero, a line was read, and the return value indicates the length in bytes. If equal to zero, end of stream was reached. If less than zero, an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="a97dac33660a5fb7333807bb90812a641"></a><!-- doxytag: member="link.h::link_fd" ref="a97dac33660a5fb7333807bb90812a641" args="(struct link *link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_fd </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the underlying file descriptor of a link. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The integer file descriptor of the link. </dd></dl>

</div>
</div>
<a class="anchor" id="a621e6102436eeca74c1bd46b0c680873"></a><!-- doxytag: member="link.h::link_buffer_empty" ref="a621e6102436eeca74c1bd46b0c680873" args="(struct link *link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_buffer_empty </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether a link has unread contents in its <a class="el" href="structbuffer.html">buffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if <a class="el" href="structbuffer.html">buffer</a> is empty, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acc347b042e023a279eec60de1395e9ae"></a><!-- doxytag: member="link.h::link_address_local" ref="acc347b042e023a279eec60de1395e9ae" args="(struct link *link, char *addr, int *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_address_local </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the local address of the link in text format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to a string of at least <a class="el" href="link_8h.html#aee1eac35b3b0cc6899cdc3ee0af78f4e">LINK_ADDRESS_MAX</a> bytes, which will be filled with a text representation of the local IP address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Pointer to an integer, which will be filled with the TCP port number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Positive on success, zero on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab692af1dacd63beb4d333fb8b5d117dc"></a><!-- doxytag: member="link.h::link_address_remote" ref="ab692af1dacd63beb4d333fb8b5d117dc" args="(struct link *link, char *addr, int *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_address_remote </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the remote address of the link in text format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to a string of at least <a class="el" href="link_8h.html#aee1eac35b3b0cc6899cdc3ee0af78f4e">LINK_ADDRESS_MAX</a> bytes, which will be filled with a text representation of the remote IP address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Pointer to an integer, which will be filled with the TCP port number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Positive on success, zero on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a40884871d97e2b9bd6bac5b62a1ca217"></a><!-- doxytag: member="link.h::link_tune" ref="a40884871d97e2b9bd6bac5b62a1ca217" args="(struct link *link, link_tune_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_tune </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3">link_tune_t</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tune a link for interactive or bulk performance. </p>
<p>A link may be tuned at any point in its lifecycle. <a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3aca07a3aeb6ab870e21c4ad322c11329c">LINK_TUNE_INTERACTIVE</a> is best used for building latency-sensitive interactive or RPC applications. <a class="el" href="link_8h.html#a0c250676329168686ded80c4f738e7d3ab0b1f1df5c3a5e1bc4da27498d3bcf83">LINK_TUNE_BULK</a> is best used to large data transfers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to be tuned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The desired tuning mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2130f3c33a717a38fb0a0ca143e9ed85"></a><!-- doxytag: member="link.h::link_poll" ref="a2130f3c33a717a38fb0a0ca143e9ed85" args="(struct link_info *array, int nlinks, int msec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_poll </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlink__info.html">link_info</a> *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nlinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a activity on a an array of links. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>Pointer to an array of <a class="el" href="structlink__info.html">link_info</a> structures. Each one should contain a pointer to a valid link and have the events field set to the events (<a class="el" href="link_8h.html#a0d5ec33b12de7dda233ea05bbacc7c65">LINK_READ</a> or <a class="el" href="link_8h.html#af4b78ceac793977641f745a92d98a6fa">LINK_WRITE</a>) of interest. Upon return, each one will have the revents field filled with the events that actually occurred. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nlinks</em>&nbsp;</td><td>The length of the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msec</em>&nbsp;</td><td>The number of milliseconds to wait for activity. Zero indicates do not wait at all, while -1 indicates wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of links available to read or write. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 10 Jul 2014 for cctools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
